<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">ADS复习笔记 | mio的博客</title>
  
    <link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/hutaoicon.png">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "秋山澪の小站";
  mashiro_option.author_name = "小站";
  mashiro_option.site_url = "https://orwell-yu.github.io/";
  mashiro_option.v_appId = "cufCqTylUQUH7Ez5kCgC3fbR-MdYXbMMI";
  mashiro_option.v_appKey = "lychiSFCksLLUOndXBDAsg3A";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://image.anosu.top/pixiv/direct".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
<meta name="generator" content="Hexo 6.0.0"></head>

<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://orwell-yu.github.io/">
          <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>这是一个二次元的博客？</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/Orwell-Yu" target="_blank" class="social-github" title="github">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://space.bilibili.com/350209137?spm_id_from=333.1007.0.0" target="_blank" class="social-github" title="bilibili">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/bilibili.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/legend-67-50" target="_blank" class="social-github" title="zhihu">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://twitter.com/yu_zhewen" target="_blank" class="social-github" title="Twitter">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/twitter.png">
                  </a>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">秋山澪の</span>
            <span class="shironeko">小站</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E7%94%9F%E6%B4%BB/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%B5%84%E6%BA%90/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E9%9A%8F%E6%83%B3/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/%E6%82%A6%E8%AF%BB/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/%E5%9B%BE%E9%9B%86/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/cover.jpg);" src="https://gcore.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/cover.jpg">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      ADS复习笔记</h1>
      <p class="entry-census">
        <span>
          <a href="">
            <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio%20avatar.jpg">
          </a>
        </span>
        <span>
          <a href="">mio</a>
        </span>
        <span class="bull">
        ·</span>
        2023-6-27<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="Advanced-Data-Structure-and-Algorithm-Analysis"><a href="#Advanced-Data-Structure-and-Algorithm-Analysis" class="headerlink" title="Advanced Data Structure and Algorithm Analysis"></a>Advanced Data Structure and Algorithm Analysis</h1><h2 id="Prolegomenon"><a href="#Prolegomenon" class="headerlink" title="Prolegomenon"></a>Prolegomenon</h2><h3 id="Grading-Policies"><a href="#Grading-Policies" class="headerlink" title="Grading Policies"></a>Grading Policies</h3><p><strong>Homework(10)</strong><br><strong>Discussions or quiz(10)</strong><br><strong>Research Project(30)</strong></p>
<blockquote>
<p>done in groups of 3<br>choose 2 out of 7<br>Report(20+20)/2 points<br>In-class presentation(10~15minutes,10 points)<br>The speaker will be chosen randomly<br>E-mail to sign up for presentation<br>Bonus </p>
</blockquote>
<p><strong>MidTerm(10)</strong><br><strong>Final Exam(40)</strong></p>
<blockquote>
<p>You can replace the MidTerm by a higher grade in Final Exam </p>
</blockquote>
<ul>
<li>E-mail denghaoran@zju.edu.cn before 6th March to send your group.</li>
</ul>
<h2 id="AVL-Trees-Splay-Trees-and-Amortized-Analysis"><a href="#AVL-Trees-Splay-Trees-and-Amortized-Analysis" class="headerlink" title="AVL Trees,Splay Trees and Amortized Analysis"></a>AVL Trees,Splay Trees and Amortized Analysis</h2><h3 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h3><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>speed up searching(with insertion and deletion)</p>
<p><strong>Recall</strong>:To solve this problem,the time complexity is:</p>
<ul>
<li>Array: $O(N)$ (Search) ; $O(1)$ (Insert)</li>
<li>Sorted Array: $O(logN)$ (Search) ; $O(N)$ (Insert, because we need to move the elements after the insertion point)</li>
<li>Binary Sorted Tree: $O(height)$ (Search); $O(height)$(Insert)<br>However ,in the worst case ,the $O(height)$ is $O(N)$</li>
</ul>
<h4 id="Optimize-Balanced-Tree"><a href="#Optimize-Balanced-Tree" class="headerlink" title="Optimize:Balanced Tree"></a>Optimize:Balanced Tree</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20224312.jpg" alt="Picture"></p>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p><strong>Balanced Tree</strong><br>An empty binary tree is height balanced.  If $T$ is a nonempty binary tree with $T_L$ and $T_R$ as its left and right subtrees, then $T$ is height balanced iff</p>
<ol>
<li>$T_L$ and $T_R$ are height balanced</li>
<li>$|h_L-h_R|\leq1$ where $h_L$ and $h_R$ are the heights of $T_L$ and $T_L$ , respectively.</li>
</ol>
<p><strong>Balance Factor(BF)</strong><br>The Balance Factor(BF) of a node=$h_L-h_R$ .<br> In an AVL Tree ,$BF(node)=-1,0,or 1$.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225301.jpg" alt="Picture"><br>The BF of an empty tree is 0.</p>
<h4 id="Tree-Roation"><a href="#Tree-Roation" class="headerlink" title="Tree Roation"></a>Tree Roation</h4><ol>
<li><strong>Tree Rotation</strong> is an operation on a binary tree that changes the suructure without interfering with the order of elements.</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225339.jpg" alt="Picture"></p>
<ol>
<li>After a rotation,the side of rotation increase its height by 1 whilst the side opposite the rotation decreases its height similarly.</li>
</ol>
<p><strong>pseudo code of Left Rotation</strong></p>
<pre><code>Tree Temp = A-&gt;Left
A-&gt;Left = B
B-&gt;Right = Temp
</code></pre><ol>
<li>The time complexity is $O(1)$.</li>
</ol>
<h4 id="Insertion-of-an-AVL-Tree"><a href="#Insertion-of-an-AVL-Tree" class="headerlink" title="Insertion of an AVL Tree"></a>Insertion of an AVL Tree</h4><h5 id="RR-Rotation"><a href="#RR-Rotation" class="headerlink" title="RR Rotation"></a>RR Rotation</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225446.jpg" alt="Picture"><br><strong>RR Rotation:</strong><br>In General:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225536.jpg" alt="Picture"><br><strong>Note:</strong><br>A is <strong>NOT</strong> necessarily thr root of the tree.<strong>A is the first Node that has a wrong BF after the insertion</strong>.<br><strong>The insertion</strong> could be just happened in the right subtree of B <strong>but NOT necessarliy be the right child of B</strong>.</p>
<h5 id="LL-Rotation"><a href="#LL-Rotation" class="headerlink" title="LL Rotation"></a>LL Rotation</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225633.jpg" alt="Picture"><br><strong>Mind the NOTE!</strong><br>In General:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225706.jpg" alt="Picture"></p>
<h5 id="LR-Rotation"><a href="#LR-Rotation" class="headerlink" title="LR Rotation"></a>LR Rotation</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225803.jpg" alt="Picture"><br>In General:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225827.jpg" alt="Picture"></p>
<h5 id="RL-Rotation"><a href="#RL-Rotation" class="headerlink" title="RL Rotation"></a>RL Rotation</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20225920.jpg" alt="Picture"><br>In General:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-02-28%20230008.jpg" alt="Picture"></p>
<p><strong>注意：</strong><br>单旋转(Single Rotation)发生在要插入的值<strong>不在</strong>关键边(连接BF值产生异常的点和其相邻点的边)<strong>之间</strong>。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230228200953.jpg" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230228201012.jpg" alt=""><br>图中虚线的边即为关键边，图中待插入的13不在关键边的4 ~ 7之间；12不在关键边13 ~ 14之间。<br>双旋转(Double Rotation)发生在要插入的值<strong>在</strong>关键边的值<strong>之间</strong>，并分为RL旋转与LR旋转。<br>旋转时$k_2$成为最后的根节点，$k_2$左子树给$k_1$作为右子树，$k_2$右子树给$k_3$作为左子树。$k_1$、$k_3$分别作为$k_2$的左右子树。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230228201900.jpg" alt=""><br>图中BF值出现异常的点为$k_1$，与其相连的点为$k_3$，判断是LR旋转还是RL旋转的点为$k_2$。</p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><blockquote>
<p>Read the declaration and functions in [1] Figures 4.42 – 4.48</p>
</blockquote>
<h4 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h4><p>$n_h$=$F_n$-$1$ where $F_n$ is the $n$th Fibonacci number, $n_h$ is the minimum number of nodes in an AVL tree of height $h$.<br>$n_h$-&gt;$((1+\sqrt{5})/2)^h$<br>$h$-&gt;$O(ln(N))$</p>
<h3 id="Splay-Tree"><a href="#Splay-Tree" class="headerlink" title="Splay Tree"></a>Splay Tree</h3><h4 id="Target-1"><a href="#Target-1" class="headerlink" title="Target"></a>Target</h4><p>Any $M$ consecutive tree opertaions starting from an empty tree take at most $O(M log N)$ time.</p>
<h4 id="Insertion-of-a-Splay-Tree"><a href="#Insertion-of-a-Splay-Tree" class="headerlink" title="Insertion of a Splay Tree"></a>Insertion of a Splay Tree</h4><p>X:a Node that is NOT root<br>P:parent of X<br>G:grandParent of X<br>Spaly Tree:每次对一个节点进行操作（访问，删除）后，都将该节点递归地旋转到根节点。</p>
<h5 id="Case1-P-is-the-root"><a href="#Case1-P-is-the-root" class="headerlink" title="Case1:P is the root"></a>Case1:P is the root</h5><p>Rotate X and P</p>
<h5 id="Case2-P-is-not-the-root"><a href="#Case2-P-is-not-the-root" class="headerlink" title="Case2:P is not the root"></a>Case2:P is not the root</h5><h6 id="Zig-zag-Double-Rotation"><a href="#Zig-zag-Double-Rotation" class="headerlink" title="Zig-zag:Double Rotation"></a>Zig-zag:Double Rotation</h6><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-01%20100840.jpg" alt="Picture"></p>
<h6 id="Zig-zig-Single-Rotation"><a href="#Zig-zig-Single-Rotation" class="headerlink" title="Zig-zig:Single Rotation"></a>Zig-zig:Single Rotation</h6><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-01%20100913.jpg" alt="Picture"></p>
<h5 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h5><blockquote>
<p>Read the 32-node example given in Figures 4.52 – 4.60</p>
</blockquote>
<p><strong>Note</strong><br>四种旋转情况的总结（适用于选择题画图）<br>其中①②表示操作的顺序<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-06%20185317.png" alt=""></p>
<h4 id="Deletion-of-a-Splay-Tree"><a href="#Deletion-of-a-Splay-Tree" class="headerlink" title="Deletion of a Splay Tree"></a>Deletion of a Splay Tree</h4><ol>
<li>Find(X) <em>The Node X will be at root.</em></li>
<li>Remove(X) <em>There will be two subtrees $T_L$ and $T_R$.</em></li>
<li>FindMax($T_L$) <em>The Largest element will be the root of $T_L$, and has NO right child.</em></li>
</ol>
<h3 id="Appendix：Implementation-in-C-AVL-Tree-Splay-Tree"><a href="#Appendix：Implementation-in-C-AVL-Tree-Splay-Tree" class="headerlink" title="Appendix：Implementation in C(AVL Tree,Splay Tree)"></a>Appendix：Implementation in C(AVL Tree,Splay Tree)</h3><p>详见<code>Project1.c</code><br>其中，AVL Tree的删除与普通二叉搜索树相同，为<code>Delete()</code>函数。<br>Splay Tree相关部分需要先初始化<code>NullNode</code>变量。</p>
<h3 id="Amortized-Analysis-均摊分析"><a href="#Amortized-Analysis-均摊分析" class="headerlink" title="Amortized Analysis(均摊分析)"></a>Amortized Analysis(均摊分析)</h3><h4 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h4><p><strong>The target of a Splay Tree:</strong> Any $M$ consecutive tree opertaions starting from an empty tree take at most $O(M log N)$ time.<br>—<strong>Amortized time bound</strong></p>
<h4 id="Aggregate-analysis-聚合分析"><a href="#Aggregate-analysis-聚合分析" class="headerlink" title="Aggregate analysis(聚合分析)"></a>Aggregate analysis(聚合分析)</h4><p><strong>Idea</strong><br>Show that for all n, a sequence of n operations takes worst-case time T(n) in total. In the worst case, the average cost, or amortized cost, per operation is therefore $T(n)/n$.</p>
<p>【<strong>Example</strong>】Stack with <code>MultiPop(int k,Stack S)</code></p>
<pre><code class="lang-C">Algorithm  &#123;
    while ( !IsEmpty(S) &amp;&amp; k&gt;0 ) &#123;
        Pop(S);
        k - -;
    &#125; /* end while-loop */ 
&#125;
</code></pre>
<p>Consider a sequence of n <code>Push</code>,<code>Pop</code>,and <code>MultiPop</code> operations on an initially empty stack.<br>Because we can pop each object from the stack at most once for each time we have pushed it onto the stack.<br>$sizeof(S) \leq n$<br>$T_{amortized}= O( n )/n = O(1)$</p>
<h4 id="Accounting-method-信用方法"><a href="#Accounting-method-信用方法" class="headerlink" title="Accounting method(信用方法)"></a>Accounting method(信用方法)</h4><p><strong>Idea</strong><br>When an operation’s amortized cost exceeds its actual cost, we assign the difference to specific objects in the data structure as credit. Credit can help pay for later operations whose amortized cost is less than their actual cost.<br><strong>Note</strong><br>For all sequences of n operations, we must have:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-01%20101851.jpg" alt=""></p>
<p>【<strong>Example</strong>】Stack with <code>MultiPop(int k,Stack S)</code></p>
<pre><code class="lang-C">    while ( !IsEmpty(S) &amp;&amp; k&gt;0 ) &#123;
        Pop(S);
        k - -;
    &#125; /* end while-loop */ 
&#125;
</code></pre>
<p>Consider a sequence of n <code>Push</code>,<code>Pop</code>,and <code>MultiPop</code> operations on an initially empty stack.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-01%20102027.jpg" alt=""></p>
<h4 id="Potential-method-势能方法"><a href="#Potential-method-势能方法" class="headerlink" title="Potential method(势能方法)"></a>Potential method(势能方法)</h4><p><strong>Idea</strong><br>Take a closer look at the credit.<br>为了避免给每一种操作都设计一个均摊代价，我们设计一个势能函数来统一化设计均摊代价。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20132907.png" alt=""><br>In general, a good potential function should always <strong>assume its minimum</strong> at the start of the sequence.<br>【<strong>Example0</strong>】Stack with <code>MultiPop(int k,Stack S)</code></p>
<pre><code class="lang-C">    while ( !IsEmpty(S) &amp;&amp; k&gt;0 ) &#123;
        Pop(S);
        k - -;
    &#125; /* end while-loop */ 
&#125;
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20133450.png" alt=""><br>【<strong>Example1</strong>】  Splay Trees: $T<em>{amortized}$ = $O( log N )$<br>$\Phi(T)=\Sigma</em>{i \in T} ln(S(i))$<br>$S(i)$:以<code>x</code>为根的子树中的节点个数。也叫做子树的质。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20134002.png" alt=""><br><strong>Appendix:Math</strong><br>If $a + b ≤ c$, and a and b are both positive integers, then:<br>$log{a} + log{b} ≤ 2 log{c} - 2$<br><strong>Proof:</strong><br>By the arithmetic-geometric mean inequality,<br>$(ab)^{1/2} ≤ (a+b)/2$<br>Thus<br>$(ab)^{1/2} ≤ c/2$<br>Squaring both sides gives<br>$ab ≤ c^2/4$<br>Taking logarithms of both sides proves the lemma.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20135417.png" alt=""><br>其中，<code>Zig-zag</code>和<code>Zig-zig</code>都是双旋转，开销为2。<br><strong><code>Zig-zag</code>中</strong>：<br>$R_2(X)$和$R_1(G)$都是整棵树的质，故相互抵消。$R_1(P)&lt;R_1(X)$,故放缩。<br><strong><code>Zig-zig</code>中</strong>：<br>$R_1(X)+R_2(G) \le 2R_2(X)-2$<br>$2+R_2(X)-R_1(X)+R_2(P)-R_1(P)+R_2(G)-R_2(G) \le 2R_2(X) -2 R_1(X) +R_2(P)-R_1(P) \le 3(R_2(X) - R_1(X))$</p>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Choose-the-correct-answer"><a href="#Choose-the-correct-answer" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li>If the depth of an AVL tree is 6 (the depth of an empty tree is defined to be -1), then the minimum possible number of nodes in this tree is:<br>A.13<br>B.17<br>C.20<br>D.33<blockquote>
<p><strong>Answer</strong>: D<br> $n<em>h$ = $n</em>{h-1} +n<em>{h-2} + 1$<br>又 $depth = height - 1$<br>故$n</em>{depth=6}$ = $n_7$ = 33</p>
</blockquote>
</li>
<li>Insert 2, 1, 4, 5, 9, 3, 6, 7 into an initially empty AVL tree. Which one of the following statements is FALSE? (1分)<br>A. 4 is the root<br>B. 2 and 6 are siblings<br>C. 3 and 7 are siblings<br>D. 9 is the parent of 7<blockquote>
<p><strong>Answer</strong>: C The following figure shows the AVL tree after inserting.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20160526180231876.png" alt=""></p>
</blockquote>
</li>
<li>For the result of accessing the keys 3, 9, 1, 5 in order in the splay tree in the following figure, which one of the following statements is FALSE? (1分)<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20160527093228170.png" alt=""><br>A. 5 is the root<br>B. 1 and 9 are siblings<br>C. 6 and 10 are siblings<br>D. 3 is the parent of 4<blockquote>
<p><strong>Answer</strong>: D<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/access3.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/access9.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/access1.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/access5.png" alt=""></p>
</blockquote>
</li>
</ol>
<h2 id="Red-Black-Trees-and-B-Trees"><a href="#Red-Black-Trees-and-B-Trees" class="headerlink" title="Red-Black Trees and B+ Trees"></a>Red-Black Trees and B+ Trees</h2><h3 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a>Red-Black Trees</h3><h4 id="Target-2"><a href="#Target-2" class="headerlink" title="Target"></a>Target</h4><p>Balanced binary seach tree using a key called <em>color</em>.</p>
<h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><p><strong>Red-Black Tree</strong><br>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：<strong>根</strong>节点是<strong>黑色</strong>。</li>
<li>性质3：每个<strong>叶子</strong>节点（NIL）是<strong>黑色</strong>。(所有叶子节点<strong>都是哨兵</strong>，哨兵都是<strong>黑色</strong>的)</li>
<li>性质4：每个<strong>红色</strong>结点的两个子结点一定都是<strong>黑色</strong>。</li>
<li>性质5：任意一结点到每个叶子结点的<strong>简单路径</strong>都包含<strong>数量相同</strong>的<strong>黑</strong>结点。</li>
</ul>
<p><strong>性质3</strong>存在的意义：<br>为了保证不存在奇怪的红黑树，所有<strong>孩子为空的节点</strong>都必须是<strong>哨兵</strong>，是<strong>黑色</strong>的，这样极度不平衡的树会<strong>不满足</strong>性质5。</p>
<p><strong>black-height</strong><br>The black-height of any node x,denoted by <code>bh(x)</code>,is the number of <strong>black</strong> nodes on any simple path from x(<strong>x not included</strong>) down to a leaf.<code>bh(Tree)=bh(root)</code>.</p>
<p>【<strong>Lemma</strong>】<br>A red-black tree with N internal nodes has height at most $2ln(N +1)$.</p>
<p><strong>Proof</strong>：</p>
<p><strong>Lemma1:</strong> For any node x, $sizeof(x) \geq 2^{bh(x)} – 1$.<br>If $h(x) = 0$, x is <code>NULL</code> -&gt; $sizeof(x) = 2^0 – 1 = 0$<br>Suppose it is true for all x with $h(x) \leq k$.<br>For x with $h(x) = k + 1$, $bh(child) = bh(x) \space or \space bh(x) – 1 $<br>Since $h(child) \leq k$, $sizeof(child) \geq 2^{bh(child)} – 1 \geq 2^{bh(x) – 1} – 1$<br>Hence $sizeof(x) = 1 + 2sizeof(child) \geq 2^{bh(x)} – 1$</p>
<p><strong>Lemma2:</strong> $bh(Tree) \geq h(Tree) / 2$<br>Since for every red node, both of its children must be black, hence on any simple path from <em>root</em> to a leaf, at least half the nodes (<em>root</em> not included) must be black.<br>$Sizeof(root) = N \geq 2^{bh(Tree)} – 1 \geq 2^{h/2} – 1$</p>
<p>由<strong>Lemma1</strong>和<strong>Lemma2</strong>可以得到<strong>Lemma</strong>的结论。</p>
<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>由于贸然插入黑色节点很有可能会导致性质5出现问题，故我们尽量插入<strong>红色</strong>节点。<br>综合考虑五条性质，插入<strong>红色</strong>节点时，<strong>只有性质2</strong>和<strong>性质4</strong>有可能会被破坏。</p>
<h5 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20211745.png" alt=""><br>此时插入的红色节点<code>z</code>依然可能破坏性质2或者4，故作迭<strong>代处理</strong>。<br>定义<code>z</code>, <code>z.p</code>, <code>y</code>, <code>z’</code><br>循环终止条件：<strong>为了保证满足性质4</strong>。<br>自底向上修正树，z的子树都满足红黑性质<br>结束后把根节点染成黑色<br>循环过程中，如果<code>z</code>变为根节点，则(2)被破坏，(4)被保留；否则<code>z.p</code>及其祖先的颜色不会改变，(2)被保留，如果<code>z.p</code>为红色则(4)被破坏。性质4<strong>只可能</strong>在<code>z</code>和<code>z.p</code>之间被破坏<br>循环开始前，如果<code>z.p</code>是根，则红黑树性质决定<code>z.p</code>为黑色，循环调整之前不会改变<code>z.p</code>的颜色<br>循环结束后，<code>z.p</code>是黑色的（如果<code>z</code>为根节点那么其父节点哨兵结点也是黑色的），性质(4)不会被破坏，只有可能性质(2)被破坏，所以对根节点进行染色<br>还有三项对称情况。</p>
<h5 id="Case-2-amp-Case-3"><a href="#Case-2-amp-Case-3" class="headerlink" title="Case 2 &amp; Case 3"></a>Case 2 &amp; Case 3</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20212542.png" alt=""><br>case 2、3<strong>不需要</strong>迭代。<br>对于case2、3来说，红黑树插入操作<strong>循环总数不超过2</strong>，因为case2、3一旦被执行就结束了。</p>
<h5 id="Algorithm-Analysis-1"><a href="#Algorithm-Analysis-1" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h5><p>总的来说，红黑树的插入操作中，我们有：<br>$T = O( h ) = O( lnN )$</p>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><p>When we do deletions,we must add 1 blcak to the path of the replacing node.<br>If the node is red,we can delete it directly because it has no influence on th red-black tree.</p>
<ul>
<li>Delete a leaf node :  Reset its parent link to NIL.(only if the node is black originally)</li>
<li>Delete a degree 1 node :  Replace the node by its single child.</li>
<li>Delete a degree 2 node :<ol>
<li>Replace the node by the largest one in its left subtree or the smallest one in its right subtree.(keep the color)</li>
<li>Delete the replacing node from the subtree.</li>
</ol>
</li>
</ul>
<p><strong>登场人物</strong>：4个Case<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20213823.png" alt=""><br>分别操作(Case 1 见上图)<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-07%20213942.png" alt=""><br>兄弟红易兄弟黑，换色单旋接着推；<br>侄黑父红换兄色，父侄双黑染红兄，上推；<br>近侄红来远侄黑，旋转能把模样改；<br>远侄红来单旋转，父兄换色侄变黑。</p>
<h3 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B+ Trees"></a>B+ Trees</h3><h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h4><p>A B+ tree of order M is a tree with the following structural properties:</p>
<ul>
<li>The root is either a leaf or has between 2 and M children.</li>
<li>All nonleaf nodes (except the root) have between $\lceil M/2 \rceil$ and $M$ children.</li>
<li>All leaves are at the same depth.</li>
</ul>
<p>Assume each nonroot leaf also has between $\lceil M/2 \rceil$ and $M$ children.</p>
<h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><pre><code class="lang-C">Btree Find ( ElementType X, Btree T ) 
&#123; 
    Search from root to leaf for X and find the proper leaf node;
    if ( X is in this node ) 
            return this node;
    else
            return NULL;
&#125;
</code></pre>
<h4 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h4><pre><code class="lang-C">Btree  Insert ( ElementType X,  Btree T ) 
&#123; 
    Search from root to leaf for X and find the proper leaf node;
    Insert X;
    while ( this node has M+1 keys ) &#123;
            split it into 2 nodes with [(M+1)/2 ]  and [(M+1)/2 ] keys, respectively;
            if (this node is the root)
                create a new root with two children;
            check its parent;
    &#125;
&#125;
</code></pre>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="Choose-the-correct-answer-1"><a href="#Choose-the-correct-answer-1" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li><p>In the red-black tree that results after successively inserting the keys 41; 38; 31; 12; 19; 8 into an initially empty red-black tree, which one of the following statements is FALSE?<br>A.38 is the root<br>B.19 and 41 are siblings, and they are both red<br>C.12 and 31 are siblings, and they are both black<br>D.8 is red</p>
<blockquote>
<p><strong>Answer: B</strong> 把红黑树看作B+树，同一节点左右值为红色，不同层连接节点为黑色。19和41不是兄弟节点，因为他们不在同一层。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230622145345.jpg" alt=""></p>
</blockquote>
</li>
<li><p>After deleting 15 from the red-black tree given in the figure, which one of the following statements must be FALSE?<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/129.png" alt=""><br>A.11 is the parent of 17, and 11 is black<br>B.17 is the parent of 11, and 11 is red<br>C.11 is the parent of 17, and 11 is red<br>D.17 is the parent of 11, and 17 is black</p>
<blockquote>
<p><strong>Answer: C</strong><br>删除节点时，如果删除的是中间节点，用左子树最大值或者右子树最小值替换，递归直到叶子节点，然后删除叶子节点。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230622145714.jpg" alt=""></p>
</blockquote>
</li>
<li><p>Insert 3, 1, 4, 5, 9, 2, 6, 8, 7, 0 into an initially empty 2-3 tree (with splitting). Which one of the following statements is FALSE?<br>A.7 and 8 are in the same node<br>B.the parent of the node containing 5 has 3 children<br>C.the first key stored in the root is 6<br>D.there are 5 leaf nodes</p>
<blockquote>
<p><strong>Answer: A</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230622150249.jpg" alt=""></p>
</blockquote>
</li>
<li><p>After deleting 9 from the 2-3 tree given in the figure, which one of the following statements is FALSE?<br>A.the root is full<br>B.the second key stored in the root is 6<br>C.6 and 8 are in the same node<br>D.6 and 5 are in the same node</p>
<blockquote>
<p><strong>Answer: D</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230622150645.jpg" alt=""></p>
</blockquote>
</li>
<li><p>Which of the following statements concerning a B+ tree of order M is TRUE?<br>A.the root always has between $2$ and $M$ children<br>B.not all leaves are at the same depth<br>C.leaves and nonleaf nodes have some key values in comon<br>D.all nonleaf nodes have between $⌈M/2⌉$ and $M$ children</p>
<blockquote>
<p><strong>Answer: D</strong><br>A.根节点不一定有$2$到$M$个孩子，因为根节点可能是叶子节点。<br>B.所有叶子节点都在同一层。<br>C.叶子节点和非叶子节点没有共同的key值，因为叶子节点不存储key值。<br>D.非叶子节点的孩子数在$⌈M/2⌉$和$M$之间。</p>
</blockquote>
</li>
</ol>
<h2 id="重要：AVL树、splay树-伸展树-和红黑树比较"><a href="#重要：AVL树、splay树-伸展树-和红黑树比较" class="headerlink" title="重要：AVL树、splay树(伸展树)和红黑树比较"></a>重要：AVL树、splay树(伸展树)和红黑树比较</h2><p><strong>一、AVL树：</strong></p>
<p>优点：查找、插入和删除，最坏复杂度均为$O(logN)$。实现操作简单</p>
<blockquote>
<p>如过是随机插入或者删除，其理论上可以得到$O(logN)$的复杂度，但是实际情况大多不是随机的。如果是随机的，则AVL树能够达到比红黑树更优的结果，因为AVL树的高度更低。如果只进行插入和查找，则AVL树是优于红黑树的，因为红黑树更多的优势还是在删除动作上。</p>
</blockquote>
<p>缺点：</p>
<ol>
<li>借助高度或平衡因子，为此需要改造元素结构，或额外封装—&gt;伸展树可以避免。</li>
<li>实测复杂度与理论复杂度上有差距。插入、删除后的旋转成本不菲。删除操作后，最多旋转$O(logN)$次，(Knuth证明，平均最坏情况下概率为0.21次)，若频繁进行插入/删除操作，得不偿失。</li>
<li>单次动态调整后，全树拓扑结构的变化量可达$O(logN)$次。—&gt;红黑树为$O(1)$</li>
</ol>
<p><strong>二、伸展树(splay tree)</strong></p>
<p>优点：</p>
<ol>
<li>无需记录节点高度和平衡因子，编程实现简单易行</li>
<li>分摊复杂度为$O(logN)$</li>
<li>局部性强，缓存命中率极高时，效率甚至可以更高。</li>
</ol>
<p>注：伸展树是根据数据访问的局部性而来的主要是：</p>
<ol>
<li>刚刚被访问的节点，极有可能在不久之后再次被访问到</li>
<li>将被访问的下一个节点，极有可能就处于不久之前被访问过的某个节点的附近。</li>
</ol>
<p>缺点：</p>
<ol>
<li>仍不能保证单次最坏情况的出现，不适用效率敏感的场合</li>
<li>复杂度分析比较复杂</li>
</ol>
<p><strong>三、红黑树</strong><br>优点:</p>
<ol>
<li>所有的插入、删除、查找操作的复杂度都是$O(logN)$</li>
<li>插入操作能够在最多2次旋转后达到平衡状态，而删除操作更是能够在一次旋转后达到平衡状态。删除操作有可能导致递归的双黑修正，但是在旋转之前，只是染色而树的结构没有任何实质性的改变，因此速度优于AVL树。</li>
<li>红黑树可以保证在每次插入或删除操作之后的重平衡过程中，全书拓扑结构的更新仅涉及常数个节点。尽管最坏情况下需对$O(logN)$个节点重染色，但就分摊意义而言，仅为$O(1)$个。</li>
</ol>
<p>缺点：左右子树高度相差比AVL树大。</p>
<h2 id="总结：AVL树、splay树-伸展树-和红黑树比较"><a href="#总结：AVL树、splay树-伸展树-和红黑树比较" class="headerlink" title="总结：AVL树、splay树(伸展树)和红黑树比较"></a>总结：AVL树、splay树(伸展树)和红黑树比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th>树</th>
<th>插入</th>
<th>删除</th>
<th>查找</th>
<th>空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVL树</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(N)$</td>
<td></td>
</tr>
<tr>
<td>伸展树</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(N)$</td>
<td></td>
</tr>
<tr>
<td>红黑树</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(logN)$</td>
<td>$O(N)$</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>（均摊下红黑树插入、删除为$O(1)$）</p>
<h2 id="Inverted-File-Index"><a href="#Inverted-File-Index" class="headerlink" title="Inverted File Index"></a>Inverted File Index</h2><h3 id="Inverted-File-Index-1"><a href="#Inverted-File-Index-1" class="headerlink" title="Inverted File Index"></a>Inverted File Index</h3><h4 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h4><p><strong>Index</strong> is a mechanism for locating a given term in a text.<br><strong>Inverted file</strong> contains a list of pointers(e.g. the number of a page) to all occurrences of that term in the text.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-23%20154517.png" alt=""><br>简单来说，inverted是因为它是根据term来索引的，而不是根据文档来索引的。也就是说用词找文档，而不是用文档找词。<br>为了更快的找到匹配项，我们先考虑频率低的词，因为它们的文档数目更少，所以我们可以先在这些词中找到匹配项，然后再在这些文档中找到匹配项。</p>
<h4 id="Index-Generateor"><a href="#Index-Generateor" class="headerlink" title="Index Generateor"></a>Index Generateor</h4><pre><code class="lang-c++">while ( read a document D ) &#123;
    while ( read a term T in D ) &#123;
        if ( Find( Dictionary, T ) == false )
            Insert( Dictionary, T );
        Get T’s posting list;
        Insert a node to T’s posting list;
    &#125;
&#125;
Write the inverted index to disk;
</code></pre>
<h4 id="Distributed-indexing"><a href="#Distributed-indexing" class="headerlink" title="Distributed indexing"></a>Distributed indexing</h4><p>Each node contains index of a subset of collection<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-23%20160835.png" alt=""><br>第二种相对更好，因为第一种划分法，如果1号服务器挂了，那么所有涉及A~C的搜索都将无法继续。</p>
<h4 id="Dynamic-indexing"><a href="#Dynamic-indexing" class="headerlink" title="Dynamic indexing"></a>Dynamic indexing</h4><p>Docs come in over time</p>
<ul>
<li>postings updates for terms already in dictionary</li>
<li>new terms added to dictionary</li>
</ul>
<p>Docs get deleted<br>创建一个临时性辅助index，每次更新在辅助index中，搜索时再合并到主index中。</p>
<h4 id="Index-Compression"><a href="#Index-Compression" class="headerlink" title="Index Compression"></a>Index Compression</h4><ul>
<li>删除不必要的词汇如a,the等再建立索引。</li>
<li>每次都记录与上一次出现的距离，而不是绝对位置，这样可以节省空间（否则很长的表导致绝对位置很大）。</li>
</ul>
<h4 id="Word-Stemming"><a href="#Word-Stemming" class="headerlink" title="Word Stemming"></a>Word Stemming</h4><ul>
<li>词干提取：将单词的词缀去掉，只保留词根。如：running -&gt; run</li>
<li>Process a word so that only its stem or root form is left. </li>
</ul>
<h4 id="Stop-Words"><a href="#Stop-Words" class="headerlink" title="Stop Words"></a>Stop Words</h4><ul>
<li>一些常用词，如a,the等，可以不用索引，因为它们出现的频率太高，而且它们的出现并不能帮助我们找到更好的匹配项。</li>
<li>Some words are so common that almost every document contains them, such as “a” “the” “it”.  It is useless to index them.  They are called stop words.  We can eliminate them from the original documents.</li>
</ul>
<h4 id="Thresholding-阈值"><a href="#Thresholding-阈值" class="headerlink" title="Thresholding 阈值"></a>Thresholding 阈值</h4><ul>
<li>Document: only retrieve the top x documents where the documents are ranked by weight</li>
<li>Query: Sort the query terms by their frequency in ascending order; search according to only some percentage of the original query terms.The world has a <strong>low frequency</strong> in the query, so it is <strong>more important</strong> to the query.<br>相当于把搜索范围缩小了，但是搜索结果的质量也会下降，所以这个阈值要合理设置。</li>
</ul>
<h3 id="Measuring-the-Performance-of-an-Index"><a href="#Measuring-the-Performance-of-an-Index" class="headerlink" title="Measuring the Performance of an Index"></a>Measuring the Performance of an Index</h3><p><strong>Data Retrieval</strong> Performance Evaluation (after establishing correctness)</p>
<ul>
<li>Response time</li>
<li>Index space</li>
</ul>
<p><strong>Information Retrieval</strong> Performance Evaluation</p>
<ul>
<li>How relevant is the answer set?</li>
</ul>
<h4 id="Relevance-only-for-imformation-retrieval"><a href="#Relevance-only-for-imformation-retrieval" class="headerlink" title="Relevance(only for imformation retrieval)"></a>Relevance(only for imformation retrieval)</h4><p>Relevance measurement requires 3 elements:</p>
<ol>
<li>A benchmark document collection</li>
<li>A benchmark suite of queries</li>
<li>A binary assessment of either Relevant or Irrelevant for each query-doc pair</li>
</ol>
<h4 id="Precision-and-Recall"><a href="#Precision-and-Recall" class="headerlink" title="Precision and Recall"></a>Precision and Recall</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-23%20162211.png" alt=""><br><strong>Precision:</strong> the percentage of the retrieved documents that are relevant<br><strong>Recall:</strong> the percentage of the relevant documents that are retrieved<br>$Precision = \frac{Retrieved \ and \ Relevant}{Retrieved}$<br>$Recall = \frac{Retrieved \ and \ Relevant}{Relevant}$<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-23%20165008.png" alt=""></p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="Judge-the-following-statements"><a href="#Judge-the-following-statements" class="headerlink" title="Judge the following statements"></a>Judge the following statements</h4><ol>
<li>While accessing a term, hashing is faster than search trees.<blockquote>
<p>True<br>可以通过搜索树、哈希表的方式来存储和访问term，而哈希表花费的是常数时间，所以访问更快。当然，哈希表存在存储不灵活等问题。</p>
</blockquote>
</li>
<li>In distributed indexing, document-partitioned strategy is to store on each node all the documents that contain the terms in a certain range.<blockquote>
<p>False<br>考分布式索引，以文件为分割的索引将文件号为一个范围内的文件存在一个节点上。</p>
</blockquote>
</li>
<li>When evaluating the performance of data retrieval, it is important to measure the relevancy of the answer set.<blockquote>
<p>False<br>这里要注意，表现分为 data retrieval 和 information retrieval，要注意两者的区分。前者的标准是<strong>response time 与 index file space</strong>，后者才是<strong>relevancy of the answer set</strong>。</p>
</blockquote>
</li>
<li>Precision is more important than recall when evaluating the explosive detection in airport security.<blockquote>
<p>False<br>Both important.</p>
<h4 id="Choose-the-correct-answer-2"><a href="#Choose-the-correct-answer-2" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4></blockquote>
</li>
<li>When measuring the relevancy of the answer set, if the precision is high but the recall is low, it means that:<br>A. most of the relevant documents are retrieved, but too many irrelevant documents are returned as well<br>B. most of the retrieved documents are relevant, but still a lot of relevant documents are missed<br>C. most of the relevant documents are retrieved, but the benchmark set is not large enough<br>D. most of the retrieved documents are relevant, but the benchmark set is not large enough<blockquote>
<p><strong>Answer: B</strong><br>精确度高而回收率低，说明搜索到的文件中不相关文件少，但是仍有大量相关文件没有搜索到。</p>
</blockquote>
</li>
<li>Which of the following is NOT concerned for measuring a search engine?<br>A. How fast does it index<br>B. How fast does it search<br>C. How friendly is the interface<br>D. How relevant is the answer set<blockquote>
<p><strong>Answer: C</strong><br>衡量搜索引擎的指标主要是：建立索引的速度、搜索速度、对查询语句的处理。</p>
</blockquote>
</li>
<li>There are 28000 documents in the database. The statistic data for one query are shown in the following table. The recall is: __</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Relevant</th>
<th>Irrelevant</th>
</tr>
</thead>
<tbody>
<tr>
<td>Retrieved</td>
<td>4000</td>
<td>12000</td>
</tr>
<tr>
<td>Not Retrieved</td>
<td>8000</td>
<td>4000</td>
</tr>
</tbody>
</table>
</div>
<p>A.14%<br>B.25%<br>C.33%<br>D.50%</p>
<blockquote>
<p><strong>Answer: C</strong><br>$Recall=\frac {Retrieved \space and \space Relevant}  {Relevant}=4000/(4000+8000)=33\% $</p>
</blockquote>
<h2 id="Leftist-Heaps-and-Skew-Heaps"><a href="#Leftist-Heaps-and-Skew-Heaps" class="headerlink" title="Leftist Heaps and Skew Heaps"></a>Leftist Heaps and Skew Heaps</h2><h3 id="Leftist-Heap"><a href="#Leftist-Heap" class="headerlink" title="Leftist Heap"></a>Leftist Heap</h3><h4 id="Recall-1"><a href="#Recall-1" class="headerlink" title="Recall"></a>Recall</h4><p><strong>Heap:</strong> Structure Property + Order Property<br>结构性质：</p>
<ul>
<li>堆是完全二叉树</li>
<li>堆的每一个子树都是堆</li>
</ul>
<p>顺序性质：</p>
<ul>
<li>堆的每一个孩子都比自己大（小）</li>
</ul>
<p>堆的操作：</p>
<ul>
<li>percolate up &amp; percolate down</li>
</ul>
<p>堆的合并：</p>
<ul>
<li>开销为$O(N)$，线性的把两个堆中的元素逐一插入。我们现在就要加速这一过程。</li>
</ul>
<h4 id="Leftist-Heap-1"><a href="#Leftist-Heap-1" class="headerlink" title="Leftist Heap"></a>Leftist Heap</h4><p><strong>Structure Property</strong>:</p>
<ul>
<li>a binary tree,but <strong>unbalanced</strong></li>
</ul>
<p><strong>Order Property</strong>:</p>
<ul>
<li>the same as normal heap</li>
</ul>
<h4 id="Definiition"><a href="#Definiition" class="headerlink" title="Definiition"></a>Definiition</h4><h5 id="NPL-The-null-path-length"><a href="#NPL-The-null-path-length" class="headerlink" title="NPL,The null path length"></a>NPL,The null path length</h5><p>The null path length,$Npl(x)$,of any node $X$ is the length of the <strong>shortest path</strong> from $X$ to a node <strong>without two childeren</strong>. Define Npl(NULL)=-1.<br><strong>Note:</strong><br>$Npl(x)=min{Npl(c)+1}$ , for all c as children of x</p>
<h5 id="Leftist-Heap-2"><a href="#Leftist-Heap-2" class="headerlink" title="Leftist Heap"></a>Leftist Heap</h5><p>The leftist heap property is that for every node x in the heap,the null path length of the left child is <strong>at least as large as</strong>  ($\geq $) that of the right child.<br>这个过程就要求左倾堆的左子树（起码看起来）要比右子树长，至少不会太短。</p>
<p><strong>Example:</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-21%20142211.png" alt=""></p>
<p><strong>【Theorem】</strong>：<br>A leftist tree with $r$ nodes <strong>on the right path</strong> must have at least $2^r-1$ nodes.</p>
<p>So we can find that the <strong>length of the right path</strong> of a leftist tree with $N$ nodes is $\lfloor log{(N+1)}\rfloor$</p>
<h4 id="Merge-Operation-Recursive"><a href="#Merge-Operation-Recursive" class="headerlink" title="Merge Operation Recursive"></a>Merge Operation Recursive</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-21%20142435.png" alt=""></p>
<ol>
<li>比较需要合并的两棵树树根节点谁更小，大的与小的右子树合并</li>
<li>递归方法合并根节点小的右子树和根节点大的整棵树。</li>
<li>比较新树的左右子树哪一个的$Npl$更大，若右边更大则交换左右子树。</li>
</ol>
<h5 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h5><pre><code class="lang-C">struct TreeNode 
&#123; 
    ElementType Element;
    PriorityQueue Left;
    PriorityQueue Right;
    int Npl;
&#125; ;
</code></pre>
<h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><pre><code class="lang-C">PriorityQueue  Merge ( PriorityQueue H1, PriorityQueue H2 )
&#123; 
    if ( H1 == NULL )   return H2;    
    if ( H2 == NULL )   return H1;    
    if ( H1-&gt;Element &lt; H2-&gt;Element )  return Merge1( H1, H2 );
    else return Merge1( H2, H1 );
&#125;

static PriorityQueue
Merge1( PriorityQueue H1, PriorityQueue H2 )
&#123; 
    if ( H1-&gt;Left == NULL )     /* single node */
        H1-&gt;Left = H2;    /* H1-&gt;Right is already NULL 
                    and H1-&gt;Npl is already 0 */
    else &#123;
        H1-&gt;Right = Merge( H1-&gt;Right, H2 );     /* Step 1 &amp; 2 */
        if ( H1-&gt;Left-&gt;Npl &lt; H1-&gt;Right-&gt;Npl )
            SwapChildren( H1 );    /* Step 3 */
        H1-&gt;Npl = H1-&gt;Right-&gt;Npl + 1;
    &#125; /* end else */
    return H1;
&#125;
</code></pre>
<h5 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h5><p>$T_p = O(log N)$</p>
<h4 id="Merge-Operation-Iterative"><a href="#Merge-Operation-Iterative" class="headerlink" title="Merge Operation Iterative"></a>Merge Operation Iterative</h4><ol>
<li>Sort the right paths without changing their left children</li>
<li>Swap children if necessary</li>
</ol>
<h5 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h5><pre><code class="lang-C++">// 定义左偏树结点结构体
struct Node &#123;
    int val; // 结点值
    int dist; // 结点距离
    Node* left; // 左子结点
    Node* right; // 右子结点
    Node(int v): val(v), dist(0), left(nullptr), right(nullptr) &#123;&#125; // 构造函数
&#125;;
// 合并两个左偏树，返回合并后的根结点
Node* merge(Node* x, Node* y) &#123;
    if (!x) return y; // 如果x为空，返回y
    if (!y) return x; // 如果y为空，返回x
    if (x-&gt;val &gt; y-&gt;val) swap(x, y); // 保证x的值小于等于y的值
    stack&lt;Node*&gt; st; // 创建一个栈，用来存储沿途修改的路径
    while (true) &#123;
        if (!x-&gt;right) &#123; // 如果x没有右子结点，直接将y作为其右子结点，并结束循环
            x-&gt;right = y;
            break;
        &#125;
        st.push(x); // 将x压入栈中，记录修改路径
        x = x-&gt;right; // 将x移动到其右子结点上
        if (x-&gt;val &gt; y-&gt;val) swap(x, y); // 保证x的值小于等于y的值
    &#125;
    while (!st.empty()) &#123; // 从栈中弹出修改过的结点，并调整其距离和左右子结点位置，保持左偏性质
        Node* p = st.top();// 弹出一个父结点p
        p-&gt;right = x; // 将p的右子结点设为当前处理的结点x（初始为合并后的右子树）
        if (!p-&gt;left || p-&gt;left-&gt;dist &lt; p-&gt;right-&gt;dist) &#123;
            swap(p-&gt;left, p-&gt;right); // 如果p没有左子结点或者其左子距离小于右子距离，则交换其左右子结点位置（保持左偏性质）
        &#125;
        p-&gt;dist = p-&gt;right ? p-&gt;right-&gt;dist + 1 : 0; // 更新p的距离为其右子距离加一（如果有右子）或者零（如果没有）
        x = p; // 将当前处理的结点设为p（向上回溯）
    &#125;
    return x; // 返回最终合并后的根节点（初始为最底层修改过的父节点）
&#125;
</code></pre>
<h5 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h5><p>$T_p = O(log N)$</p>
<h4 id="DeleteMin-Operation"><a href="#DeleteMin-Operation" class="headerlink" title="DeleteMin Operation"></a>DeleteMin Operation</h4><ol>
<li>Delete the root</li>
<li>Merge the two subtrees</li>
</ol>
<h5 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h5><p>$T_p = O(log N)$</p>
<h2 id="Skew-Heap"><a href="#Skew-Heap" class="headerlink" title="Skew Heap"></a>Skew Heap</h2><h4 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h4><p><strong>Idea:</strong><br>Always swap the left and right children except that the largest of all the nodes on the right paths does not have its children swapped.  <strong>No Npl.</strong><br>总是交换左右子节点，除了右边路径上最大的节点没有交换它的子节点。<strong>不需要Npl。</strong><br>由于没有npl，它可以节省更多空间。斜堆也不要求堆是左倾堆。<br>由于斜堆并不是严格的左倾堆，最坏的情况下右路长度可能为<code>N</code>，因此采用递归调用<code>merge</code>的风险是出现<code>stack overflow</code>。</p>
<h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><ol>
<li>如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。</li>
<li>如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。</li>
<li>合并后，交换新堆根节点的左孩子和右孩子。</li>
</ol>
<h5 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h5><pre><code class="lang-C">SkewNode* merge_skewheap(SkewHeap x, SkewHeap y)
&#123;
    if(x == NULL)
        return y;
    if(y == NULL)
        return x;

    // 合并x和y时，将x作为合并后的树的根；
    // 这里的操作是保证: x的key &lt; y的key
    if(x-&gt;key &gt; y-&gt;key)
        swap_skewheap_node(y, x);

    // 将x的右孩子和y合并，
    // 合并后直接交换x的左右孩子，而不需要像左倾堆一样考虑它们的npl。
    SkewNode *tmp = merge_skewheap(x-&gt;right, y);
    x-&gt;right = x-&gt;left;
    x-&gt;left  = tmp;

    return x;
&#125;
</code></pre>
<p>对于<code>Skew Heap</code>插入新的节点实质上也可以看作<code>Merge</code>操作。</p>
<h4 id="Amortized-Analysis"><a href="#Amortized-Analysis" class="headerlink" title="Amortized Analysis"></a>Amortized Analysis</h4><p><strong>【Definition】</strong> A node p is <strong>heavy</strong> if the number of descendants of p’s right subtree is at least half of the number of descendants of p, and light otherwise.  Note that the number of descendants of a node includes the node itself.<br>如果节点p的右子树的子代数至少是p子代数的一半，则节点p为<strong>重</strong>，否则为轻。请注意，节点的后代数量包括节点本身。</p>
<p>The <strong>only</strong> nodes whose heavy/light status can change are nodes that are initially on the right path.<br>合并操作中，<strong>只有右路径</strong>上的节点轻重状态回改变。右路径上<strong>重节点一定变轻节点，而轻节点不一定变重节点</strong>。</p>
<p>这里我们使用均摊分析中的势能方法分析斜堆的算法复杂度。<br>如果我们如下定义$D_i$:<br>$D_i=$the root of the resulting tree</p>
<p>那么，我们如下定义势能函数：</p>
<p>$\Phi(D_i)=$number of <strong>heavy</strong> nodes</p>
<p>设合并前两个斜堆的右路径上的<strong>重节点</strong>数量分别为$h_1$,$h_2$，所有左路径上的<strong>重节点</strong>数量为$h$（由于这些重节点的轻重<strong>不再</strong>变化），所有右路径上的轻节点数量分别为$l_1$,$l_2$。<br>我们可以观察到，在合并之前，<br>$\Phi_0=h_1+h_2+h$</p>
<p>由于在合并过程中，重节点<strong>一定</strong>变轻节点（左右子树要经过交换），而轻节点<strong>不一定</strong>变重节点。<br>经过合并之后：<br>$\Phi<em>N\leq l_1+l_2$（最差情况，<strong>所有</strong>的轻节点都叛变了）<br>而最差情况：<br>$T</em>{worst} = l<em>1 + h_1 + l_2 + h_2$<br>所以，根据势能方法的定义，<br>$T</em>{amortized} = T<em>{worst} + \Phi_N – \Phi_0  \leq 2 (l_1 + l_2)$<br>而$l = O( log N )$<br>故$T</em>{amortized} = O( log N )$</p>
<h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="Judgement"><a href="#Judgement" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>The result of inserting keys $1$ to $2^{k−1}$ for any $k&gt;4$ in order into an initially empty skew heap is always a full binary tree.<blockquote>
<p>True<br>我去，还真是。自己试验一下就知道了。</p>
</blockquote>
</li>
<li>The right path of a skew heap can be arbitrarily long.<blockquote>
<p>True<br>没规定斜堆的规模？那当然可以任意长。</p>
</blockquote>
</li>
</ol>
<h4 id="Choose-the-correct-answer-3"><a href="#Choose-the-correct-answer-3" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li>Merge the two leftist heaps in the following figure. Which one of the following statements is FALSE?<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/131.png" alt=""><br>A.2 is the root with 11 being its right child<br>B.the depths of 9 and 12 are the same<br>C.21 is the deepest node with 11 being its parent<br>D.the null path length of 4 is less than that of 2<blockquote>
<p><strong>answer: D</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20160603200803673.png" alt=""><br>D选项中4和2的npl都是2,故选D。</p>
</blockquote>
</li>
<li>We can perform BuildHeap for leftist heaps by considering each element as a one-node leftist heap, placing all these heaps on a queue, and performing the following step: Until only one heap is on the queue, dequeue two heaps, merge them, and enqueue the result. Which one of the following statements is FALSE?<br>A. in the $k$-th run, $⌈N/2^k⌉$ leftist heaps are formed, each contains $2^k$ nodes.<br>B.the worst case is when $N=2^K$ for some integer $K$<br>C.the time complexity $T(N)=O( \frac{N}2 log2 ^0 + \frac{N}{2^2}log2^1 + \frac{N}{2^3}​log2 ^2 +⋯+ \frac{N}{2^K}log2^{K−1} )$ for some integer $K$ so that $N=2 K$<br>D. the worst case time complexity of this algorithm is $Θ(NlogN)$<blockquote>
<p><strong>answer: D</strong><br>C正确，求和可以算出$T(N)=Θ(N)$，而D选项中的$Θ(NlogN)$是错误的。</p>
</blockquote>
</li>
<li>Insert keys 1 to 15 in order into an initially empty skew heap. Which one of the following statements is FALSE? (3分)<br>A. the resulting tree is a complete binary tree<br>B. there are 6 leaf nodes<br>C. 6 is the left child of 2<br>D. 11 is the right child of 7<blockquote>
<p><strong>answer: B</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20160604205651425.png" alt=""></p>
</blockquote>
</li>
<li>Merge the two skew heaps in the following figure. Which one of the following statements is FALSE?<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20210502100453611.png" alt=""><br>A.15 is the right child of 8<br>B.14 is the right child of 6<br>C.1 is the root<br>D.9 is the right child of 3<blockquote>
<p><strong>answer: A</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230628150437.jpg" alt=""></p>
</blockquote>
</li>
</ol>
<h2 id="Binomial-Queue"><a href="#Binomial-Queue" class="headerlink" title="Binomial Queue"></a>Binomial Queue</h2><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>A <strong>binomial queue</strong> is not a heap-ordered tree, but rather <strong>a collection</strong> of heap-ordered trees, <strong>known as a forest</strong>.  Each heap-ordered tree is a <strong>binomial tree</strong>.</p>
<p>A binomial tree of height 0 is a one-node tree.</p>
<p>A binomial tree, $B<em>k$, of height $k$ is formed by attaching a binomial tree, $B</em>{k – 1}$, to the root of another binomial tree, $B_{k – 1}$.</p>
<p>仅包含一个结点的有序树是一棵二项树称为$B<em>0$树。二项树$B_k$由两棵$B</em>{k-1}$树组成，其中一棵$B<em>{k-1}$树的根作为另一棵$B</em>{k-1}$树根的最左孩子$(k≥0)$。</p>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-28%20134549.png" alt=""></p>
<p><strong>Note</strong>:$B<em>k$ consists of a root with k    children, which are  $B_0, B_1, …, B</em>{k – 1} $.  $B_k$ has exactly  $2^k$ nodes. The number of nodes at depth $d$ is $\tbinom{k}{d}$.</p>
<p>$B_k$ structure + heap order + one binomial tree for each height.<br>$\Rightarrow$ A priority queue of any size can be uniquely represented by a collection of binomial trees.<br>一些由二项树<strong>构成</strong>的树林被称作二项堆，是一种优先队列。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-03-28%20134816.png" alt=""></p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><h4 id="FindMin"><a href="#FindMin" class="headerlink" title="FindMin"></a>FindMin</h4><p>The minimum key is in one of the roots.<br>There are at most $\lceil logN \rceil$    roots, hence $T_p = O(logN)$.</p>
<p>We can remember the minimum and update whenever it is changed.Then this operation will take $O(1)$.</p>
<h4 id="Merge-1"><a href="#Merge-1" class="headerlink" title="Merge"></a>Merge</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20151703.png" alt=""><br>在合并前先用二进制算出两个二项树的最大高度，然后将两个二项树的根结点按照高度从小到大排列，将相同高度的二项树合并，最后将剩余的二项树连接起来。<br><strong>Note</strong>: If the smallest nonexistent binomial tree is Bi , then $T_p = Const · (i + 1)$.<br>Performing $N$ Inserts on an initially empty binomial queue will take $O(N)$ worst-case time.  Hence the average time is constant.</p>
<h4 id="DeleteMin"><a href="#DeleteMin" class="headerlink" title="DeleteMin"></a>DeleteMin</h4><p>Step 1: FindMin in $B_k$<br>Step 2: Remove $B_k$ from $H$,the rest of $H$ is a binomial queue $H’$<br>Step 3: Remove root from $B_k$,the rest of $B_k$ is a binomial queue $H”$<br>Step 4: <code>Merge (H&#39;, H&quot;)</code><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20152053.png" alt=""></p>
<h4 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="lang-C">//definition
typedef struct BinNode *Position;
typedef struct Collection *BinQueue;
typedef struct BinNode *BinTree;  /* missing from p.176 */

struct BinNode 
&#123; 
    ElementType        Element;
    Position        LeftChild;
    Position         NextSibling;
&#125; ;

struct Collection 
&#123; 
    int            CurrentSize;  /* total number of nodes */
    BinTree    TheTrees[ MaxTrees ];
&#125;;

//merge two binomial trees
BinTree Merge( BinTree T1, BinTree T2 )
&#123;
    if( T1-&gt;Element &gt; T2-&gt;Element )
        return Merge( T2, T1 );
    T2-&gt;NextSibling = T1-&gt;LeftChild;
    T1-&gt;LeftChild = T2;
    return T1;
&#125;

//merge two binomial queues
BinQueue Merge_BinQueue( BinQueue H1, BinQueue H2 )
&#123;
    BinTree T1, T2, Carry = NULL;
    int i, j;

    if( H1-&gt;CurrentSize + H2-&gt;CurrentSize &gt; Capacity )
        Error( &quot;Merge would exceed capacity&quot; );

    H1-&gt;CurrentSize += H2-&gt;CurrentSize;
    for( i = 0, j = 1; j &lt;= H1-&gt;CurrentSize; i++, j *= 2 )
    &#123;
        T1 = H1-&gt;TheTrees[ i ]; T2 = H2-&gt;TheTrees[ i ];

        switch( !!T1 + 2 * !!T2 + 4 * !!Carry )
        &#123;
          case 0: /* No trees */
          case 1: /* Only H1 */
            break;
          case 2: /* Only H2 */
            H1-&gt;TheTrees[ i ] = T2;
            H2-&gt;TheTrees[ i ] = NULL;
            break;
          case 4: /* Only Carry */
            H1-&gt;TheTrees[ i ] = Carry;
            Carry = NULL;
            break;
          case 3: /* H1 and H2 */
            Carry = Merge( T1, T2 );
            H1-&gt;TheTrees[ i ] = H2-&gt;TheTrees[ i ] = NULL;
            break;
          case 5: /* H1 and Carry */
            Carry = Merge( T1, Carry );
            H1-&gt;TheTrees[ i ] = NULL;
            break;
          case 6: /* H2 and Carry */
            Carry = Merge( T2, Carry );
            H2-&gt;TheTrees[ i ] = NULL;
            break;
          case 7: /* All three */
            H1-&gt;TheTrees[ i ] = Carry;
            Carry = Merge( T1, T2 );
            H2-&gt;TheTrees[ i ] = NULL;
            break;
        &#125;
    &#125;
    return H1;
&#125;

//delete the minimum element in binomial queue
ElementType DeleteMin( BinQueue H )
&#123;
    int i, j;
    int MinTree; /* The tree with the minimum item */
    BinQueue DeletedQueue;
    Position DeletedTree, OldRoot;
    ElementType MinItem;

    if( IsEmpty( H ) )
    &#123;
        Error( &quot;Empty binomial queue&quot; );
        return -Infinity;
    &#125;

    MinItem = Infinity;
    for( i = 0; i &lt; MaxTrees; i++ )
    &#123;
        if( H-&gt;TheTrees[ i ] &amp;&amp;
            H-&gt;TheTrees[ i ]-&gt;Element &lt; MinItem )
        &#123;
            /* Update minimum */
            MinItem = H-&gt;TheTrees[ i ]-&gt;Element;
            MinTree = i;
        &#125;
    &#125;

    DeletedTree = H-&gt;TheTrees[ MinTree ];
    OldRoot = DeletedTree;
    DeletedTree = DeletedTree-&gt;LeftChild;
    free( OldRoot );

    DeletedQueue = Initialize( );
    DeletedQueue-&gt;CurrentSize = ( 1 &lt;&lt; MinTree ) - 1;
    for( j = MinTree - 1; j &gt;= 0; j-- )
    &#123;
        DeletedQueue-&gt;TheTrees[ j ] = DeletedTree;
        DeletedTree = DeletedTree-&gt;NextSibling;
        DeletedQueue-&gt;TheTrees[ j ]-&gt;NextSibling = NULL;
    &#125;

    H-&gt;TheTrees[ MinTree ] = NULL;
    H-&gt;CurrentSize -= DeletedQueue-&gt;CurrentSize + 1;

    Merge_BinQueue( H, DeletedQueue );
    return MinItem;
&#125;
</code></pre>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="Judgement-1"><a href="#Judgement-1" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>To implement a binomial queue, the subtrees of a binomial tree are linked in increasing sizes.<blockquote>
<p>False<br>小的永远在上面，但是横向是没有大小限制的。</p>
</blockquote>
</li>
<li>To implement a binomial queue, left-child-next-sibling structure is used to represent each binomial tree.<blockquote>
<p>True</p>
<h4 id="Choose-the-correct-answer-4"><a href="#Choose-the-correct-answer-4" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4></blockquote>
</li>
<li>Which of the following binomial trees can represent a binomial queue of size 42?<br>A.$B_0 B_1 B_2 B_3 B_4 B_5$<br>B.$B_1 B_3 B_5$<br>C.$B_1 B_5$<br>D.$B_2 B_4$<blockquote>
<p><strong>Answer: B</strong><br>42用二进制表示就是B</p>
</blockquote>
</li>
<li>Delete the minimum number from the given binomial queues in the following figure. Which one of the following statements must be FALSE?<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/20210329185838446.png" alt=""><br>A.there are two binomial trees after deletion, which are B1 and B2<br>B.11 and 15 can be the children of 4<br>C.29 can never be the root of any resulting binomial tree<br>D.if 29 is a child of 4, then 15 must be the root of B1<blockquote>
<p><strong>Answer: C</strong><br>对于A，删除后为6个点，110，所以有B1和B2，正确。<br>对于B,C,D：首先找到最小的根为2，删除2，出现4个树，将相同的合并：4和11合并，剩下4可以和15或者29合并，所以C是可能的，选C</p>
</blockquote>
</li>
<li>Merge the two binomial queues in the following figure. Which one of the following statements must be FALSE?<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/132.png" alt=""><br>A.there are two binomial trees after merging, which are $B_2$ and $B_4$<br>B.13 and 15 are the children of 4<br>C.if 23 is a child of 2, then 12 must be another child of 2<br>D.if 4 is a child of 2, then 23 must be another child of 2<blockquote>
<p><strong>Answer: D</strong><br>对于A:一共有13+7=20个点，10100，说明有B2,B4<br>从低位开始合并，首先13和4合并变成$B_1$，4和15合并$B_2$，4可以和2或者23合并<br>对于B,是可以的。<br>对于C，说明23和2合并，另一个孩子是11和29，再和12合并，是可以的。<br>对于D，说明4和2合并，23是根，错。</p>
<h2 id="总结：左倾堆、斜堆与二项堆"><a href="#总结：左倾堆、斜堆与二项堆" class="headerlink" title="总结：左倾堆、斜堆与二项堆"></a>总结：左倾堆、斜堆与二项堆</h2><p>|堆|插入|删除最小|合并|空间|<br>|—-|—-|—-|—-|—-|<br>|左倾堆|$O(logN)$|$O(logN)$|$O(logN)$|$O(N)$|<br>|斜堆|$O(logN)$|$O(logN)$|$O(logN)$|$O(N)$|<br>|二项堆|$O(logN)$|$O(logN)$|$O(logN)$|$O(N)$|<br>二项堆插入均摊：$O(1)$</p>
</blockquote>
</li>
</ol>
<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>A sure-fire way to find the answer to a problem is to make a list of all candidate answers, examine each, and following the examination of all or some of the candidates, declare the identified answer.</p>
<p>Backtracking enables us to eliminate the explicit examination of a large subset of the candidates while still guaranteeing that the answer will be found if the algorithm is run to termination.</p>
<p>The basic idea is that suppose we have a partial solution ( $x<em>1, … , x_i$ ) where each $x_k \in S_k$ for  $1 \leq k \leq i &lt; n$.   First we add  $x</em>{i+1} \in S<em>{i+1}$ and check if ( $x_1, … , x_i, x</em>{i+1}$ ) satisfies the constrains.  If the answer is “yes” we continue to add the next x, else we delete $x<em>{i+1}$ and backtrack to the previous partial solution ( $x_1, … , x</em>{i}$ ).</p>
<p>我们不断枚举，当发现<strong>不满足条件</strong>(剪枝)时，回溯到上一步，继续枚举。</p>
<h3 id="The-Turnpike-Reconstruction-Problem"><a href="#The-Turnpike-Reconstruction-Problem" class="headerlink" title="The Turnpike Reconstruction Problem"></a>The Turnpike Reconstruction Problem</h3><p>Given N points on the x-axis with coordinates $x_1 &lt;  x_2 &lt; …&lt; x_N$ .  Assume that $x_1 = 0$.  There are $N ( N – 1 ) / 2$ distances between every pair of points.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-04%20153553.png" alt=""></p>
<pre><code class="lang-C">bool Reconstruct ( DistType X[ ], DistSet D, int N, int left, int right )
&#123; /* X[1]...X[left-1] and X[right+1]...X[N] are solved */
    bool Found = false;
    if ( Is_Empty( D ) )
        return true; /* solved */
    D_max = Find_Max( D );
    /* option 1：X[right] = D_max */
    /* check if |D_max-X[i]|D is true for all X[i]’s that have been solved */
    OK = Check( D_max, N, left, right ); /* pruning */
    if ( OK ) &#123; /* add X[right] and update D */
        X[right] = D_max;
        for ( i=1; i&lt;left; i++ )  Delete( |X[right]-X[i]|, D);
        for ( i=right+1; i&lt;=N; i++ )  Delete( |X[right]-X[i]|, D);
        Found = Reconstruct ( X, D, N, left, right-1 );
        if ( !Found ) &#123; /* if does not work, undo */
            for ( i=1; i&lt;left; i++ )  Insert( |X[right]-X[i]|, D);
            for ( i=right+1; i&lt;=N; i++ )  Insert( |X[right]-X[i]|, D);
        &#125;
    &#125;
    /* finish checking option 1 */

    if ( !Found ) &#123; /* if option 1 does not work */
        /* option 2: X[left] = X[N]-D_max */
        OK = Check( X[N]-D_max, N, left, right );
        if ( OK ) &#123;
            X[left] = X[N] – D_max;
            for ( i=1; i&lt;left; i++ )  Delete( |X[left]-X[i]|, D);
            for ( i=right+1; i&lt;=N; i++ )  Delete( |X[left]-X[i]|, D);
            Found = Reconstruct (X, D, N, left+1, right );
            if ( !Found ) &#123;
                for ( i=1; i&lt;left; i++ ) Insert( |X[left]-X[i]|, D);
                for ( i=right+1; i&lt;=N; i++ ) Insert( |X[left]-X[i]|, D);
            &#125;
        &#125;
        /* finish checking option 2 */
    &#125; /* finish checking all the options */

    return Found;
&#125;
</code></pre>
<h3 id="Eight-Queens"><a href="#Eight-Queens" class="headerlink" title="Eight Queens"></a>Eight Queens</h3><p>Find a placement of  8 queens on an 8 X 8 chessboard such that no two queens attack.</p>
<p>Two queens are said to attack iff they are in the same row, column, diagonal, or antidiagonal of the chessboard.</p>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-04%20153849.png" alt=""></p>
<pre><code class="lang-C">void EightQueens ( int k )
&#123;   int i;
    if ( k &gt; N ) &#123; /* a solution is found */
        PrintSolution( );
        return;
    &#125;
    for ( i=1; i&lt;=N; i++ ) &#123;
        X[k] = i;
        if ( Place( k ) ) /* pruning */
            EightQueens( k+1 );
    &#125;
&#125;
bool Place ( int k )
&#123;   int i;
    for ( i=1; i&lt;k; i++ ) &#123;
        if ( ( X[i] == X[k] ) || ( abs(X[i]-X[k]) == abs(i-k) ) )
            return false;
    &#125;
    return true;
&#125;
</code></pre>
<h3 id="General-Backtracking"><a href="#General-Backtracking" class="headerlink" title="General Backtracking"></a>General Backtracking</h3><pre><code class="lang-C">bool Backtracking ( int i )
&#123;   Found = false;
    if ( i &gt; N )
        return true; /* solved with (x1, …, xN) */
    for ( each xi in Si ) &#123; 
        /* check if satisfies the restriction R */
        OK = Check((x1, …, xi) , R ); /* pruning */
        if ( OK ) &#123;
            Count xi in;
            Found = Backtracking( i+1 );
            if ( !Found )
                Undo( i ); /* recover to (x1, …, xi-1) */
        &#125;
        if ( Found ) break; 
    &#125;
    return Found;
&#125;
</code></pre>
<p>回溯的效率跟S的规模、约束函数的复杂性、满足约束条件的结点数相关。<br>约束函数决定了剪枝的效率，但是如果函数本身太复杂也未必合算。<br>满足约束条件的结点数最难估计，使得复杂度分析很难完成。</p>
<h3 id="alpha-beta-Pruning"><a href="#alpha-beta-Pruning" class="headerlink" title="$\alpha$-$\beta$ Pruning"></a>$\alpha$-$\beta$ Pruning</h3><h4 id="alpha-Pruning"><a href="#alpha-Pruning" class="headerlink" title="$\alpha$ Pruning"></a>$\alpha$ Pruning</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20165925.png" alt=""></p>
<h4 id="beta-Pruning"><a href="#beta-Pruning" class="headerlink" title="$\beta$ Pruning"></a>$\beta$ Pruning</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20165942.png" alt=""></p>
<h4 id="alpha-beta-Pruning-Analysis"><a href="#alpha-beta-Pruning-Analysis" class="headerlink" title="$\alpha$-$\beta$ Pruning Analysis"></a>$\alpha$-$\beta$ Pruning Analysis</h4><p><strong>α-β pruning:</strong> when both techniques are combined.  In practice, it limits the searching to only $O(\sqrt{N})$nodes, where $N$ is the size of the full game tree.</p>
<h2 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h2><h3 id="Algorithm-Design"><a href="#Algorithm-Design" class="headerlink" title="Algorithm Design"></a>Algorithm Design</h3><p><strong>Divide</strong>: the problem into a number of sub-problems.<br><strong>Conquer</strong>: the sub-problems by solving them recursively.<br><strong>Combine</strong>: the solutions to the sub-problems into the solution for the original problem.<br><strong>General recurrence:</strong> $T(N) = aT(N/b) + f(N)$</p>
<h3 id="Closest-Points-Problem"><a href="#Closest-Points-Problem" class="headerlink" title="Closest Points Problem"></a>Closest Points Problem</h3><p>Given $N$ points in a plane.  Find the closest pair of points.  (If two points have the same position, then that pair is the closest with distance 0.)<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20183743.png" alt=""><br>解析详见PPT</p>
<h3 id="Algorithm-Analysis-2"><a href="#Algorithm-Analysis-2" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h3><h4 id="Substitution-method"><a href="#Substitution-method" class="headerlink" title="Substitution method"></a>Substitution method</h4><p>类似于数学归纳法，先猜后证明。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20184016.png" alt=""></p>
<h4 id="Recursion-tree-method"><a href="#Recursion-tree-method" class="headerlink" title="Recursion-tree method"></a>Recursion-tree method</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-11%20144025.png" alt=""><br>一个示例，用于分析算法复杂度的方法，叶子节点表示划分完成后最小子问题的时间开销，中间节点表示合并子问题的时间开销。</p>
<h4 id="Master-method"><a href="#Master-method" class="headerlink" title="Master method"></a>Master method</h4><p><strong>【Master Theorem】</strong><br>Let $a \geq 1$ and $b &gt; 1$ be constants, let $f(N)$ be a function, and let $T(N)$ be defined on the nonnegative integers by the recurrence  $T(N) = aT(N/b) + f(N)$.  Then:</p>
<ol>
<li><p>If $f(N)=O(N^{log_b{a-\epsilon}})$ for some constant $\epsilon &gt; 0$, then $T(N)=\Theta(N^{log_ba})$</p>
</li>
<li><p>If $f(N)=\Theta(N^{log_ba})$, then $T(N)=\Theta(N^{log_ba}logN)$</p>
</li>
<li><p>If $f(N)=\Omega(N^{log_b{a+\epsilon}})$ for some constant $\epsilon &gt; 0$, <strong>and if</strong>  $ af(N/b)&lt;cf(N)$ for some constant $c &lt; 1$ and all sufficiently large $N$, then $T(N)=\Theta f(N)$</p>
</li>
</ol>
<p><strong>【Example】</strong> </p>
<ul>
<li>Mergesort has $a = b = 2$, and case 2<br>$T = O( N log N )$</li>
<li>$a = b = 2$,  $f (N) = NlogN$  ?<br>$T = O( N log N )$ (X)<br>这时候主方法就挂了，因为没有满足三种中的任意一种，这种情况下要用递归树。</li>
</ul>
<p>其他两种主方法的形式：<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-11%20152946.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-11%20153132.png" alt=""></p>
<h3 id="Exercies"><a href="#Exercies" class="headerlink" title="Exercies"></a>Exercies</h3><h4 id="Choose-the-correct-answer-5"><a href="#Choose-the-correct-answer-5" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li>When solving a problem with input size N by divide and conquer, if at each stage the problem is divided into 8 sub-problems of equal size $N/3$, and the conquer step takes $O(N^2logN)$ to form the solution from the sub-solutions, then the overall time complexity is __.<br>A.$O(N^2 logN)$<br>B.$O(N^2 log^2 N)$<br>C.$O(N^3 logN)$<br>D.$O(N^{\frac{log8}{log3}} )$<blockquote>
<p><strong>Answer:A</strong><br>使用主方法的第二种形式：$a=8,b=3,f(N)=N^2logN,k=2,p=1,a&lt;b^k$，所以时间复杂度为$O(N^2logN)$</p>
</blockquote>
</li>
<li>To solve a problem with input size N by divide and conquer algorithm, among the following methods, __ is the worst.<br>A.divide into $2$ sub-problems of equal complexity $N/3$ and conquer in $O(N)$<br>B.divide into $2$ sub-problems of equal complexity $N/3$ and conquer in $O(NlogN)$<br>C.divide into $3$ sub-problems of equal complexity $N/2$ and conquer in $O(N)$<br>D.divide into $3$ sub-problems of equal complexity $N/3$ and conquer in $O(NlogN)$<blockquote>
<p><strong>Answer:C</strong><br>使用树形图分析，可以发现C的时间复杂度最高</p>
</blockquote>
</li>
<li>3-way-mergesort : Suppose instead of dividing in two halves at each step of the mergesort, we divide into three one thirds, sort each part, and finally combine all of them using a three-way-merge. What is the overall time complexity of this algorithm ?<br>A.$O(n(log^2 n))$<br>B.$O(n^2 logn)$<br>C.$O(nlogn)$<br>D.$O(n)$<blockquote>
<p><strong>Answer:C</strong><br>使用主方法第二种形式，$a=3,b=3,f(N)=N,k=1,p=0,a=b^k$，所以时间复杂度为$O(Nlog(N))$?</p>
</blockquote>
</li>
<li>Which one of the following is the lowest upper bound of $T(n)$.$T(n)$ for the following recursion $T(n)=2T(​\sqrt{n}​)+logn$?(4分)<br>A.$O(logn)$<br>B.$O(loglogn)$<br>C.$O(lognloglogn)$<br>D.$O(n)$<blockquote>
<p><strong>Answer:C</strong><br>设 $m = logn$, 则$2^m = n$<br>$T(2^m) = 2T(2^{m/2}) + m$<br>设 $G(m) = T(2^m)$，则原式转化为$G(m) = 2G(m/2) + m$<br>根据方法第二种形式，$a = 2, b = 2, k = 1, p = 0$. $a = b^k$，满足条件2，所以算法复杂度为$O（mlogm）$,又因为 $m = logn$,所以算法复杂度为$O（logn loglogn )$</p>
</blockquote>
</li>
</ol>
<h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><h3 id="Recall-2"><a href="#Recall-2" class="headerlink" title="Recall"></a>Recall</h3><p>Use a table instead of recursion.<br>动态规划最核心的思想，就在于<strong>拆分子问题</strong>，<strong>记住过往</strong>，减少重复计算。</p>
<h3 id="Fibonacci-Numbers"><a href="#Fibonacci-Numbers" class="headerlink" title="Fibonacci Numbers"></a>Fibonacci Numbers</h3><p>$F(N) = F(N – 1) + F(N – 2) $</p>
<pre><code class="lang-C">int  Fib( int N ) 
&#123; 
    if ( N &lt;= 1 ) 
        return  1; 
    else 
        return  Fib( N - 1 ) + Fib( N - 2 ); 
&#125;
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-18%20133100.png" alt=""><br>可以发现，在运算递归中，有很多重复的计算，这就是动态规划的基础。我们可以<strong>保留前两项的值</strong>，然后每次计算新的一项，这样就不用重复计算了。</p>
<pre><code class="lang-C">int  Fibonacci ( int N ) 
&#123;   int  i, Last, NextToLast, Answer; 
    if ( N &lt;= 1 )  return  1; 
    Last = NextToLast = 1;    /* F(0) = F(1) = 1 */
    for ( i = 2; i &lt;= N; i++ ) &#123; 
        Answer = Last + NextToLast;   /* F(i) = F(i-1) + F(i-2) */
        NextToLast = Last; Last = Answer;  /* update F(i-1) and F(i-2) */
    &#125;  /* end-for */
    return  Answer; 
&#125;
</code></pre>
<p>$T(N)=O(N)$</p>
<h3 id="Matrix-Chain-Multiplication"><a href="#Matrix-Chain-Multiplication" class="headerlink" title="Matrix Chain Multiplication"></a>Matrix Chain Multiplication</h3><p>Given a sequence of $N$ matrices $M<em>1, M_2, …, M_N$, where for $i = 1, 2, …, N$, matrix $M_i$ has dimension $r</em>{i-1} \times r_i$.In which order can we compute the product of $N$ matrices with minimal computing time?</p>
<p>设$b<em>i$为共有$i$个矩阵相乘得到的结果数，比如$b_2$=1,$b_3$=2,…<br>我们又递推式：<br>$b_n=\Sigma</em>{i=1}^{n-1}b<em>ib</em>{n-i}$</p>
<p>Suppose we are to multiply  $n$  matrices  $M<em>1$  $M_N$ where  $M_i$  is an $r</em>{i-1} \times r<em>i$ matrix.  Let $m</em>{ij}$ be the cost of the optimal way to compute  $M_i <em>…</em> M_j$ .  Then we have the recurrence equations:<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-18%20135050.png" alt=""></p>
<pre><code class="lang-C">/* r contains number of columns for each of the N matrices */ 
/* r[ 0 ] is the number of rows in matrix 1 */ 
/* Minimum number of multiplications is left in M[ 1 ][ N ] */ 
void OptMatrix( const long r[ ], int N, TwoDimArray M ) 
&#123;   int  i, j, k, L; 
    long  ThisM; 
    for( i = 1; i &lt;= N; i++ )   M[ i ][ i ] = 0; 
    for( k = 1; k &lt; N; k++ )&#123;/* k = j - i */ 
        for( i = 1; i &lt;= N - k; i++ ) &#123; /* For each position */ 
            j = i + k;
            M[ i ][ j ] = Infinity; 
            for( L = i; L &lt; j; L++ ) &#123; 
                ThisM = M[ i ][ L ] + M[ L + 1 ][ j ] + r[ i - 1 ] * r[ L ] * r[ j ]; 
                if ( ThisM &lt; M[ i ][ j ] )  /* Update min */ 
                M[ i ][ j ] = ThisM; 
            &#125;  /* end for-L */
        &#125;  /* end for-Left */
    &#125; 
&#125;
</code></pre>
<p>$T(N) = O(N^3)$</p>
<h3 id="Optimal-Binary-Search-Tree"><a href="#Optimal-Binary-Search-Tree" class="headerlink" title="Optimal Binary Search Tree"></a>Optimal Binary Search Tree</h3><p>Given  $N $ words $ w<em>1 &lt; w_2 &lt; …… &lt; w_N$, and the probability of searching for each  $w_i$  is  $p_i$ .  Arrange these words in a binary search tree in a way that minimize the expected total access time.<br>$T(N)=\Sigma</em>{i=1}^{N}p_i(1+d_i)$<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-18%20144607.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-18%20144701.png" alt=""><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-18%20144732.png" alt=""></p>
<h3 id="All-Pairs-Shortest-Path"><a href="#All-Pairs-Shortest-Path" class="headerlink" title="All-Pairs Shortest Path"></a>All-Pairs Shortest Path</h3><p>Given a weighted directed graph $G=(V,E)$, where $V$ is the set of vertices and $E$ is the set of edges, and each edge $e=(u,v)$ has a weight $w(e)$.  The <strong>shortest path</strong> from vertex $u$ to vertex $v$ is a path from $u$ to $v$ with the minimum total weight.  The <strong>all-pairs shortest path problem</strong> is to find the shortest path from each vertex to every other vertex.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20204249.png" alt=""></p>
<pre><code class="lang-c">/* A[ ] contains the adjacency matrix with A[ i ][ i ] = 0 */ 
/* D[ ] contains the values of the shortest path */ 
/* N is the number of vertices */ 
/* A negative cycle exists iff D[ i ][ i ] &lt; 0 */ 
void AllPairs( TwoDimArray A, TwoDimArray D, int N ) 
&#123;   int  i, j, k; 
    for ( i = 0; i &lt; N; i++ )  /* Initialize D */ 
         for( j = 0; j &lt; N; j++ )
     D[ i ][ j ] = A[ i ][ j ]; 
    for( k = 0; k &lt; N; k++ )  /* add one vertex k into the path */
         for( i = 0; i &lt; N; i++ ) 
     for( j = 0; j &lt; N; j++ ) 
        if( D[ i ][ k ] + D[ k ][ j ] &lt; D[ i ][ j ] ) 
        /* Update shortest path */ 
         D[ i ][ j ] = D[ i ][ k ] + D[ k ][ j ]; 
&#125;
</code></pre>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="Choose-the-correct-answer-6"><a href="#Choose-the-correct-answer-6" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li>Rod-cutting Problem: Given a rod of total length N inches and a table of selling prices $P_L$for lengths $L=1,2,⋯,M$. You are asked to find the maximum revenue $R_N$ obtainable by cutting up the rod and selling the pieces. For example, based on the following table of prices, if we are to sell an 8-inch rod, the optimal solution is to cut it into two pieces of lengths 2 and 6, which produces revenue $R_8=P_2+P_6=5+17=22$. And if we are to sell a 3-inch rod, the best way is not to cut it at all.</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Length L</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>Price $P_L$</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>23</td>
<td>28</td>
</tr>
</tbody>
</table>
</div>
<p>Which one of the following statements is FALSE?<br>A.This problem can be solved by dynamic programming<br>B.The time complexity of this algorithm is $O(N^2)$<br>C.If $N≤M$, we have $R<em>N =max(P_N​,max</em>{1≤i<N} (R_i +R_{N−i}​ ))$
D.If $N>M$, we have $R<em>N =max</em>{1≤i≤M} (P<em>i +R</em>{N−M}​ )$</p>
<blockquote>
<p><strong>Answer:</strong> D<br>应该是$R<em>N =max</em>{1≤i≤N} (P<em>i +R</em>{N−i}​ )$</p>
<ol>
<li>Given a recurrence equation $f<em>{i,j,k} =f</em>{i,j+1,k} +min<em>{0≤l≤k}​(f</em>{i−1,j,l}+w<em>{j,l})$. To solve this equation in an iterative way, we cannot fill up a table as follows:<br>A.<code>for k in 0 to n: for i in 0 to n: for j in n to 0</code><br>B.<code>for i in 0 to n: for j in 0 to n: for k in 0 to n</code><br>C.<code>for i in 0 to n: for j in n to 0: for k in n to 0</code><br>D.<code>for i in 0 to n: for j in n to 0: for k in 0 to n</code><br><strong>Answer:</strong> B<br>注意到在递推表达式中，$f</em>{i,j,k}$的值依赖于$f<em>{i,j+1,k}$,但是在B中，$f</em>{i,j+1,k}$的值还没有被计算出来，所以B是错误的。<h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><h3 id="General-Idea"><a href="#General-Idea" class="headerlink" title="General Idea"></a>General Idea</h3><strong>Optimization Problems:</strong><br>Given a set of constraints and an optimization function.  Solutions that satisfy the constrains are called feasible solutions.  A feasible solution for which the optimization function has the best possible value is called an optimal solution.</li>
</ol>
</blockquote>
<p><strong>The Greedy Method:</strong><br>Make the best decision at each stage, under some greedy criterion.  A decision made in one stage <strong>is not changed</strong> in a later stage, so each decision should assure feasibility.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Greedy algorithm works only if <strong>the local optimum is equal to the global optimum</strong>.</li>
<li>Greedy algorithm <strong>does not</strong> guarantee optimal solutions.  However, it generally produces solutions that are very close in value (heuristics) to the optimal, and hence is intuitively appealing when finding the optimal solution takes too much time.</li>
</ul>
<h3 id="Elements-of-the-Greedy-Strategy"><a href="#Elements-of-the-Greedy-Strategy" class="headerlink" title="Elements of the Greedy Strategy"></a>Elements of the Greedy Strategy</h3><ol>
<li>Cast the optimization problem as one in which we make a choice and are left with one subproblem to solve.</li>
<li>Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.</li>
<li>Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if we combine an optimal solution to the subproblem with the greedy choice we have made, we arrive at an optimal solution to the original problem.</li>
</ol>
<p><strong>In Chinese:</strong></p>
<ol>
<li>将优化问题视为我们做出选择并留下一个子问题需要解决的问题。</li>
<li>证明原问题总有一个最优解使得贪婪选择，使得贪婪选择总是安全的。</li>
<li>通过证明最优子结构，在做出贪婪选择后，剩下的是一个子问题，如果我们把子问题的最优解和我们所做的贪婪选择结合起来，我们就会得到原问题的最优解。</li>
</ol>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Activity-Selection-Problem"><a href="#Activity-Selection-Problem" class="headerlink" title="Activity Selection Problem"></a>Activity Selection Problem</h4><p>Given a set of activities $S = { a_1, a_2, …, a_n }$ that wish to use a resource (e.g. a classroom).  Each ai takes place during a time interval $[s_i, f_i)$.<br>Activities $a_i$ and $a_j$ are compatible if $s_i \geq f_j$ or $s_j \geq f_i$ (i.e. their time intervals do not overlap).</p>
<p><strong>Greedy Rules:might wrong</strong></p>
<ul>
<li>Greedy Rule 1: Select the interval which starts earliest (but not overlapping the already chosen intervals) (WRONG)</li>
<li>Greedy Rule 2: Select the interval with the shortest duration (but not overlapping the already chosen intervals)(WRONG)</li>
<li>Greedy Rule 3: Select the interval with the fewest conflicts with other remaining intervals (but not overlapping the already chosen intervals) (WRONG)</li>
<li>Greedy Rule 4: Select the interval which ends first (but not overlapping the already chosen intervals) (CORRECT)</li>
</ul>
<p>How to prove Greedy Rule 4 is correct?</p>
<h5 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness:"></a>Correctness:</h5><ol>
<li>Algorithm gives <strong>non-overlapping</strong> intervals</li>
<li>The result is optimal</li>
</ol>
<p><strong>【Theorem】</strong><br>Consider any nonempty subproblem $S<em>k$, and let am be an activity in $S_k$ with the earliest finish time.  Then am is included in some maximum-size subset of mutually compatible activities of $S_k$.<br><strong>Proof:</strong><br>Let $A_k$ be the optimal solution set, and aef is the activity in $A_k$ with the earliest finish time.<br>If $a_m$ and $a</em>{ef}$ are the same, we are done!  Else ……<br>replace $a<em>{ef}$ by $a_m$ and get $A_k’$.<br>Since $f_m \leq f</em>{ef}$ , $A_k’$ is another optimal solution.</p>
<h5 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation:"></a>Implementation:</h5><ol>
<li>Select the first activity; Recursively solve for the rest.</li>
<li>Remove tail recursion by iterations.</li>
</ol>
<h4 id="Huffman-Coding"><a href="#Huffman-Coding" class="headerlink" title="Huffman Coding"></a>Huffman Coding</h4><p>Given a set of characters and their frequencies, find a binary code for each character such that the total number of bits required to encode a string of characters is minimized.</p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-25%20153551.png" alt=""></p>
<h5 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation:"></a>Implementation:</h5><pre><code class="lang-C">void Huffman ( PriorityQueue  heap[ ],  int  C )
&#123;   consider the C characters as C single node binary trees,
     and initialize them into a min heap;
     for ( i = 1; i &lt; C; i++ ) &#123; 
        create a new node;
        /* be greedy here */
        delete root from min heap and attach it to left_child of node;
        delete root from min heap and attach it to right_child of node;
        weight of node = sum of weights of its children;
        /* weight of a tree = sum of the frequencies of its leaves */
        insert node into min heap;
   &#125;
&#125;
</code></pre>
<h5 id="Correctness-1"><a href="#Correctness-1" class="headerlink" title="Correctness:"></a>Correctness:</h5><ol>
<li>The greedy-choice property<br><strong>【Lemma】</strong><br>Let $C$ be an alphabet in which each character $c \in C$ has frequency $c.freq$.  Let $x$ and $y$ be two characters in $C$ having the lowest frequencies.  Then there exists an optimal prefix code for $C$ in which the codewords for $x$ and $y$ have the same length and differ only in the last bit.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-25%20153754.png" alt=""></li>
<li>The optimal substructure property<br><strong>【Lemma】</strong><br>Let $C$ be a given alphabet with frequency $c$.freq defined for each character $c<br>\in C$.  Let x and y be two characters in $C$ with minimum frequency.  Let $C’$ be the alphabet $C$ with a new character $z$ replacing $x$ and $y$, and $z.freq = x.freq + y.freq$.  Let $T’$ be any tree representing an optimal prefix code for the alphabet $C’$.  Then the tree $T$, obtained from $T’$ by replacing the leaf node for $z$ with an internal node having $x$ and $y$ as children, represents an optimal prefix code for the alphabet $C$.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-04-25%20154148.png" alt=""></li>
</ol>
<h3 id="Prove-Greedy-Algorithm"><a href="#Prove-Greedy-Algorithm" class="headerlink" title="Prove Greedy Algorithm"></a>Prove Greedy Algorithm</h3><ol>
<li>Cast the optimization problem as one in which we make a choice and are left with one subproblem to solve.</li>
<li>Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.</li>
<li>Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if we combine an optimal solution to the subproblem with the greedy choice we have made, we arrive at an optimal solution to the original problem. </li>
</ol>
<p>Beneath every greedy algorithm, there is almost always a more cumbersome dynamic-programming solution</p>
<h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-2"><a href="#Judgement-2" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>Greedy algorithm works only if the local optimum is equal to the global optimum.<blockquote>
<p>True<br>只有在局部解和全局解相等的时候可以使用贪心算法</p>
</blockquote>
</li>
<li>In a greedy algorithm, a decision made in one stage is not changed in a later stage.<blockquote>
<p>True<br>做出选择后不会改变</p>
</blockquote>
</li>
<li>Let S be the set of activities in Activity Selection Problem. Then the earliest finish activity $a_m$must be included in all the maximum-size subset of mutually compatible activities of $S$.<blockquote>
<p>False<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/微信图片_20230628211120.jpg" alt=""><br>如图，最优解可以是$a_1$，也可以是$a_2$</p>
<h2 id="NP-Completeness"><a href="#NP-Completeness" class="headerlink" title="NP-Completeness"></a>NP-Completeness</h2><h3 id="P-NP-NP-Complete-NP-Hard"><a href="#P-NP-NP-Complete-NP-Hard" class="headerlink" title="P, NP, NP-Complete, NP-Hard"></a>P, NP, NP-Complete, NP-Hard</h3><h4 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h4><p>能在多项式时间内找到解决方法的问题，比如图的2-color着色问题，我们现实中能找到复杂度在多项式时间解决的问题都是此类的。</p>
<h4 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h4><p>给与一个问题，可能你目前无法在多项式时间解决，但是如果给了你一个猜想的答案，你能在多项式时间检验 这个答案的正确性，这样的问题成为np问题。比如hanmilton回路问题， 给定一幅图，是否能找到一条经过每个顶点一次且恰好一次最后又走回来的路。<br>所以，所有的p类问题都是np问题，p是np的子集，但是p可不可能等于np问题至今仍是一个谜团。</p>
<h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p>npc特指一类特殊的问题，如果一个np的问题能够被规约转化（要求这个转化必须是多项式时间可以做到的）为该问题，即该问题的解法可以解决转化前的问题，那么这个问题就可以称为npc问题。<br>所以，npc问题是可以理解为np问题里面最难的那类问题，所有的np问题都可以泛华为该类问题。<br>比如，最大独立集，最大团 和 3-SAT问题。</p>
<h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>典型代表：停机问题。<br>np-hard问题的范围就广泛许多，它已经不局限于np问题的范围，npc问题都可以规约为np-hard问题，并且np-hard的问题也不再局限于回答是非的问题。</p>
<h4 id="Digraph-猜想"><a href="#Digraph-猜想" class="headerlink" title="Digraph(猜想)"></a>Digraph(猜想)</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/2021063018361420.png" alt=""></p>
<h3 id="Recall-some-Algorithms"><a href="#Recall-some-Algorithms" class="headerlink" title="Recall some Algorithms"></a>Recall some Algorithms</h3></blockquote>
</li>
</ol>
<ul>
<li>Euler Circuit: A circuit that traverses each edge of a graph exactly once. <strong>Polynomial time algorithm.</strong></li>
<li>Hamiltonian Circuit: A circuit that traverses each vertex of a graph exactly once. <strong>NP-Complete.</strong></li>
<li>Traveling Salesman Problem: Given a set of cities and distances between every pair of cities, find the shortest possible route that visits every city exactly once and returns to the starting point. <strong>NP-Complete.</strong></li>
<li>Single-source unweighted shortest-path problem: Given a graph $G = (V, E)$ and a distinguished source vertex $s$, find the shortest path from $s$ to every other vertex in $G$. <strong>Polynomial time algorithm.</strong></li>
<li>Single-source unweighted longest-path problem: Given a graph $G = (V, E)$ and a distinguished source vertex $s$, find the longest path from $s$ to every other vertex in $G$. <strong>NP-Complete.</strong></li>
</ul>
<h3 id="Halting-Problem"><a href="#Halting-Problem" class="headerlink" title="Halting Problem"></a>Halting Problem</h3><p><strong>【Theorem】</strong><br>The halting problem is <strong>undecidable.</strong>  That is, there is no algorithm that can take as input a program $P$ and an input $I$ and determine whether $P$ halts when run on input $I$.<br>因此，我们可以得出结论，<strong>不存在</strong>一个算法，可以判断一个程序是否会停机，这表示停机问题是<strong>NP-Hard</strong>的。<br>以下我们用反证法证明这个断言. 假设存在这样的一个函数可用于判断停机问题</p>
<pre><code class="lang-C">bool halts(char *f_code, char *t);
</code></pre>
<p>其中<code>f_code</code>是我们要进行测试的函数<code>f</code>的<code>ASCII</code>源代码, 我们可以认为对<code>f_code</code>进行编译得到了函数<code>f</code>. 当<code>f</code>对<code>t</code>停机时, <code>halts(f_code, t)</code>返回<code>true</code>; 当<code>f</code>对<code>t</code>不停机, <code>halts(f_code, t)</code>返回<code>false</code>.我们构造这样一个函数</p>
<pre><code class="lang-C">void modified_halts(char *f_code) &#123;
  if (halts(f_code, f_code)) &#123;  // 当halts(f_code, f_code)返回true
    while (true) &#123; /*empty*/ &#125;  // 死循环
  &#125;
  else &#123;                        // 当halts(f_code, f_code)返回false
    return;                     // 立即停止运行
  &#125;
&#125;
</code></pre>
<p>即当<code>f</code>对<code>f_code</code>停机时, 我们让<code>modified_halts</code>不停机; 当<code>f</code>对<code>f_code</code>不停机时,<code>modified_halts</code>停机。<br>假设<code>modified_halts</code>这个函数的<code>ASCII</code>源代码是<code>modified_halts_code</code>, 如果我们把<code>modified_halts_code</code>作为<code>modified_halts</code>的输入会是什么情况?如果<code>modified_halts</code>对<code>modified_halts_code</code>停机, 说明<code>halts(modified_halts_code, modified_halts_code)</code>返回<code>false</code>, 说明<code>modified_halts</code>对<code>modified_halts_code</code>不停机;如果<code>modified_halts</code>对<code>modified_halts_code</code>不停机, 说明<code>halts(modified_halts_code, modified_halts_code)</code>返回<code>true</code>, 说明<code>modified_halts</code>对<code>modified_halts_code</code>停机.综合以上两种情况, “<code>modified_halts</code>对<code>modified_halts_code</code>停机”当且仅当”<code>modified_halts</code>对<code>modified_halts_code</code>不停机”, 这是一个矛盾, 说明不存在这样一个<code>halts</code>函数可用于判断任意函数的可停机性。<br>以上这个证明利用的就是理发师悖论, <code>modified_halts</code>函数就像是那位克里克岛小城里的理发师, 他对并且只对那些不停机的函数停机. 当<code>modified_halts</code>函数面对他自己的函数代码时, 就像理发师该不该给他自己刮胡子一样, 将陷入两难境地。</p>
<h3 id="Turing-Machine"><a href="#Turing-Machine" class="headerlink" title="Turing Machine"></a>Turing Machine</h3><h4 id="Deterministic-Turing-Machine"><a href="#Deterministic-Turing-Machine" class="headerlink" title="Deterministic Turing Machine"></a>Deterministic Turing Machine</h4><p>A deterministic Turing machine is a 7-tuple $(Q, \Sigma, \Gamma, \delta, q<em>0, q</em>{accept}, q_{reject})$ where</p>
<ul>
<li>$Q$ is a finite set of states</li>
<li>$\Sigma$ is the input alphabet not containing the blank symbol $\sqcup$</li>
<li>$\Gamma$ is the tape alphabet, where $\sqcup \in \Gamma$ and $\Sigma \subseteq \Gamma$</li>
<li>$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times {L, R}$ is the transition function</li>
<li>$q_0 \in Q$ is the start state</li>
<li>$q_{accept} \in Q$ is the accept state</li>
<li>$q<em>{reject} \in Q$ is the reject state, where $q</em>{reject} \neq q_{accept}$</li>
<li>$q<em>{accept} \neq q</em>{reject}$</li>
<li>$\delta(q<em>{accept}, a) = \delta(q</em>{reject}, a) = undefined$ for all $a \in \Gamma$</li>
<li>$\delta(q, \sqcup) = (q, \sqcup, R)$ for all $q \in Q$</li>
<li>$\delta(q, x) = (q_{reject}, x, R)$ for all $q \in Q$ and $x \in (\Gamma - {\sqcup})$</li>
</ul>
<p>A Deterministic Turing Machine executes one instruction at each point in time.  Then depending on the instruction, it goes to the next <strong>unique</strong> instruction</p>
<h4 id="Nondeterministic-Turing-Machine"><a href="#Nondeterministic-Turing-Machine" class="headerlink" title="Nondeterministic Turing Machine"></a>Nondeterministic Turing Machine</h4><p>A nondeterministic Turing machine is a 7-tuple $(Q, \Sigma, \Gamma, \delta, q<em>0, q</em>{accept}, q_{reject})$ where</p>
<ul>
<li>$Q$ is a finite set of states</li>
<li>$\Sigma$ is the input alphabet not containing the blank symbol $\sqcup$</li>
<li>$\Gamma$ is the tape alphabet, where $\sqcup \in \Gamma$ and $\Sigma \subseteq \Gamma$</li>
<li>$\delta: Q \times \Gamma \rightarrow 2^{Q \times \Gamma \times {L, R}}$ is the transition function</li>
<li>$q_0 \in Q$ is the start state</li>
<li>$q_{accept} \in Q$ is the accept state</li>
<li>$q<em>{reject} \in Q$ is the reject state, where $q</em>{reject} \neq q_{accept}$</li>
<li>$q<em>{accept} \neq q</em>{reject}$</li>
<li>$\delta(q<em>{accept}, a) = \delta(q</em>{reject}, a) = undefined$ for all $a \in \Gamma$</li>
<li>$\delta(q, \sqcup) = (q, \sqcup, R)$ for all $q \in Q$</li>
<li>$\delta(q, x) = (q_{reject}, x, R)$ for all $q \in Q$ and $x \in (\Gamma - {\sqcup})$</li>
</ul>
<p>A Nondeterministic Turing Machine is <strong>free</strong> to choose its next step from a <strong>finite set</strong>.  And if one of these steps leads to a solution, it will always <strong>choose the correct one</strong>.</p>
<h3 id="NP-Complete-Problems-NPC-Problems"><a href="#NP-Complete-Problems-NPC-Problems" class="headerlink" title="NP-Complete Problems(NPC Problems)"></a>NP-Complete Problems(NPC Problems)</h3><p>An $NP-complete$ problem has the property that any problem in $NP$ can be <strong>polynomially reduced</strong>(规约) to it.</p>
<h4 id="What-is-a-polynomial-reduction"><a href="#What-is-a-polynomial-reduction" class="headerlink" title="What is a polynomial reduction?"></a>What is a polynomial reduction?</h4><p>Given any instance $\alpha$ of an $NP-complete$ problem $A$, we can construct an instance $\beta$ of another $NP-complete$ problem $B$ such that $\alpha$ is a yes-instance of $A$ if and only if $\beta$ is a yes-instance of $B$. We say that $A$ is polynomially reducible to $B$ if the construction of $\beta$ from $\alpha$ can be done in polynomial time.<br>也就是说，如果$A$问题的一个实例$\alpha$可以在多项式时间内转化为$B$问题的一个实例$\beta$，并且规约的过程是多项式时间的，那么我们就说$A$问题可以在多项式时间内归约到$B$问题。</p>
<h4 id="Example-of-NPC-Problems"><a href="#Example-of-NPC-Problems" class="headerlink" title="Example of NPC Problems"></a>Example of NPC Problems</h4><p><strong>Halmiltonian Cycle Problem VS Traveling Salesman Problem</strong></p>
<ul>
<li>Halmiltonian Cycle Problem: Given a graph $G$, does it contain a cycle that visits every vertex exactly once?</li>
<li>Traveling Salesman Problem: Given a complete graph  $G$ and a number $k$, does it contain a cycle that visits every vertex exactly once and has length at most $k$?</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-09%20140428.png" alt=""></p>
<p>我们每次证明一个问题是NPC问题，我们就必须要归约到一个已知的NPC问题。那么，第一个NPC问题是什么呢？<br>The first problem that was proven to be NP-complete was the Satisfiability problem (Circuit-SAT): Input a boolean expression and ask if it has an assignment to the variables that gives the expression a value of 1.<br>Cook showed in 1971 that all the problems in NP could be polynomially transformed to Satisfiability.  He proved it <strong>by solving this problem on a nondeterministic Turing machine in polynomial time.</strong></p>
<h3 id="A-Formal-Language-Framework"><a href="#A-Formal-Language-Framework" class="headerlink" title="A Formal-Language Framework"></a>A Formal-Language Framework</h3><h4 id="Abstract-Problems"><a href="#Abstract-Problems" class="headerlink" title="Abstract Problems"></a>Abstract Problems</h4><p>an abstract problem $Q$ is a binary relation on a set $I$ of problem instances and a set $S$ of problem solutions.<br><strong>【Example】</strong></p>
<ul>
<li><p>For SHORTEST-PATH problem<br>  $I = { <G, u, v>; u, v \in V }$;$G=(V, E)$ is an undirected graph<br> $S = { <u, w_1, w_2, …, w_k, v>: <u, w_1>, …, <w_k, v> \in E }.$<br> For every $i \in E$, $SHORTEST-PATH(i) = s \in S.$</p>
</li>
<li><p>For decision problem PATH:<br>  I = ${ <G, u, v, k> u, v \in V}$;$G=(V, E)$ is an undirected graph;$k ≥ 0$ is an integer<br> $S = { 0, 1 }$.<br> For every $i \in I$, $PATH(i) = 1 / 0$.</p>
</li>
</ul>
<h4 id="Formal-Language-Theory"><a href="#Formal-Language-Theory" class="headerlink" title="Formal-Language Theory"></a>Formal-Language Theory</h4><ul>
<li>An alphabet $Σ$ is a finite set of symbols</li>
<li>A language $L$ over $Σ$ is any set of strings made up of symbols from $Σ$</li>
<li>Denote empty string by $ε$ </li>
<li>Denote empty language by $Ø$ </li>
<li>Language of all strings over $Σ$ is denoted by $Σ*$</li>
<li>The complement of $L$ is denoted by $Σ*-L$  </li>
<li>The concatenation of two languages $L_1$ and $L_2$ is the language<br>$L = { x_1x_2 : x_1 ∈ L_1$ and $x_2 ∈ L_2 }$.</li>
<li>The closure or Kleene star of a language L is the language<br>$L*= {ε} ∪ L ∪ L_2 ∪ L_3 ∪ ···$,<br>where $L_k$ is the language obtained by concatenating $L$ to itself $k$ times</li>
</ul>
<h4 id="Formal-Language-Algorithm"><a href="#Formal-Language-Algorithm" class="headerlink" title="Formal-Language Algorithm"></a>Formal-Language Algorithm</h4><ul>
<li>Algorithm $A$ accepts a string $x ∈ {0, 1}*$ if $A(x) = 1$</li>
<li>Agorithm $A$ rejects a string $x$ if $A(x) = 0$</li>
<li>$A$ language $L$ is decided by an algorithm $A$ if every binary string in $L$ is accepted by $A$ and every binary string not in $L$ is rejected by </li>
<li>To accept a language, an algorithm need only worry about strings in $L$, but to decide a language, it must correctly accept or reject every string in ${0, 1}*$<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-28%20214726.png" alt=""></li>
</ul>
<h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-3"><a href="#Judgement-3" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li><p>If $L_​1 \leq p L_2$ and $L_2∈NP$, then $L_1∈NP$.</p>
<blockquote>
<p>True<br>注意&lt;=p等价于reduce to，复杂的如果是NP，那么简单的也是NP</p>
</blockquote>
</li>
<li><p>All NP-complete problems are NP problems.</p>
<blockquote>
<p>True</p>
</blockquote>
</li>
<li><p>All the languages can be decided by a non-deterministic machine.</p>
<blockquote>
<p>False<br>不确定图灵机可以用来验证NP问题的解是否是正确的，确定图灵机可以用来求解P问题。NP hard问题无法通过不确定图灵机验证</p>
</blockquote>
</li>
<li><p>All NP problems can be solved in polynomial time in a non-deterministic machine.</p>
<blockquote>
<p>True<br>不确定图灵机可用多项式时间解决NP问题</p>
</blockquote>
</li>
<li><p>If a problem can be solved by dynamic programming, it must be solved in polynomial time.</p>
<blockquote>
<p>Flase<br>0-1背包问题可以用DP解，但是复杂度不是多项式的, 原因是输入的数据不是多项式的。这种被称为伪多项式时间算法。</p>
</blockquote>
</li>
<li><p>A language $L$ belongs to NP iff there exist a two-input polynomial-time algorithm A that verifies language $L$ in polynomial time.</p>
<blockquote>
<p>True<br>这是ppt上的</p>
</blockquote>
</li>
<li><p>Given that problem A is NP-complete. If problem B is in NP and can be polynomially reduced to problem A, then problem B is NP-complete.</p>
<blockquote>
<p>False<br>B&lt;= A，但是A是NPC问题，A&lt;=B才能说明B也是NPC问题。</p>
</blockquote>
</li>
<li><p>All decidable problems are NP problems.</p>
<blockquote>
<p>False<br>还有NP hard问题, NP hard问题无法通过不确定图灵机验证</p>
</blockquote>
</li>
<li><p>All NP problems are decidable.</p>
<blockquote>
<p>True<br>可以通过不确定图灵机判断</p>
</blockquote>
</li>
<li><p>To prove problem B is NP-complete, we can use a NP-complete problem A and use a polynomial-time reduction algorithm to transform an instance of problem B to an instance of problem A.</p>
<blockquote>
<p>False<br>应该不是一个实例，而是整个问题</p>
</blockquote>
</li>
<li><p>If P = NP then the Shortest-Path (finding the shortest path between a pair of given vertices in a given graph) problem is NP-complete.</p>
<blockquote>
<p>True<br>P=NP说明所有的NP问题均可解，所有的NPC问题可解，NP=NPC</p>
</blockquote>
</li>
</ol>
<h4 id="Choose-the-correct-answer-7"><a href="#Choose-the-correct-answer-7" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4><ol>
<li><p>Among the following problems, __ is NOT an NP-complete problem.<br>A.Vertex cover problem<br>B.Hamiltonian cycle problem<br>C.Halting problem<br>D.Satisfiability problem</p>
<blockquote>
<p><strong>Answer: C</strong><br>D,SAT问题是第一个被证明的NPC问题，A是NPC问题，B是汉密尔顿回路，NPC问题。C停机问题是不可解的，选C</p>
</blockquote>
</li>
<li><p>Suppose Q is a problem in NP, but not necessarily NP-complete. Which of the following is FALSE?<br>A.A polynomial-time algorithm for SAT would sufficiently imply a polynomial-time algorithm for Q.<br>B.A polynomial-time algorithm for Q would sufficiently imply a polynomial-time algorithm for SAT.<br>C.If Q ∉P, then P≠NP.<br>D.If Q is NP-hard, then Q is NP-complete.</p>
<blockquote>
<p><strong>Answer: B</strong><br>SAT是NPC问题，如果解决了，可以解决所有NP问题<br>B， Q不一定是NPC的，所以不对.<br>C，如果Q不是P，那么说明NP没有被解决<br>D，NP-hard和NP交集是NPC</p>
</blockquote>
</li>
</ol>
<h2 id="Approximation-Algorithms"><a href="#Approximation-Algorithms" class="headerlink" title="Approximation Algorithms"></a>Approximation Algorithms</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><h4 id="Approximation-Ratio"><a href="#Approximation-Ratio" class="headerlink" title="Approximation Ratio"></a>Approximation Ratio</h4><p>An algorithm has an approximation ratio of  $\rho(n)$ if, for any input of size $n$, the cost $C$ of the solution produced by the algorithm is within a factor of $\rho(n)$ of the cost $C^<em>$ of an <strong>optimal solution</strong>(精确解):<br>$max(\frac{C}{C^</em>},\frac{C^<em>}{C} )\leq \rho(n)$<br>If an algorithm achieves an approximation ratio of $\rho(n)$, we call it a <em>*$\rho(n)$-approximation algorithm.</em></em></p>
<h4 id="Approximation-Scheme"><a href="#Approximation-Scheme" class="headerlink" title="Approximation Scheme"></a>Approximation Scheme</h4><p>An approximation scheme for an optimization problem is an approximation algorithm that takes as input not only an instance of the problem, but also a value $\epsilon &gt; 0$ such that for any fixed $\epsilon$, the scheme is a <strong>$(1+ \epsilon)$-approximation algorithm.</strong><br>(完全可近似)，如果是固定比例的近似算法，我们称之为可近似算法。<br>If the Approximate Ratio is a function of the input size $n$,我们认为他不可近似。</p>
<h4 id="Polynomial-Time-Approximation-Scheme"><a href="#Polynomial-Time-Approximation-Scheme" class="headerlink" title="Polynomial-Time Approximation Scheme"></a>Polynomial-Time Approximation Scheme</h4><p>We say that an approximation scheme is a polynomial-time approximation scheme (PTAS) if for any fixed $\epsilon$ &gt; 0, the scheme runs in time polynomial in the size $n$ of its input instance.</p>
<h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Approximate-Bin-Packing"><a href="#Approximate-Bin-Packing" class="headerlink" title="Approximate Bin Packing"></a>Approximate Bin Packing</h4><p>Given N items of sizes  $S_1 , S_2 , …, S_N ,$ such that $0 &lt; S_i \leq 1$ for all<br>$1 &lt; i \leq N$ .  Pack these items in the fewest number of bins, each of which has unit capacity.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-16%20134223.png" alt=""></p>
<h5 id="Solution-1-Next-Fit-Algorithm"><a href="#Solution-1-Next-Fit-Algorithm" class="headerlink" title="Solution 1:Next Fit Algorithm"></a>Solution 1:Next Fit Algorithm</h5><pre><code class="lang-C">void NextFit ( )
&#123;   read item1;
    while ( read item2 ) &#123;
        if ( item2 can be packed in the same bin as item1 )
    place item2 in the bin;
        else
    create a new bin for item2;
        item1 = item2;
    &#125; /* end-while */
&#125;
</code></pre>
<p><strong>【Theorem】</strong> Let $M$ be the optimal number of bins required to pack a list I of items.  Then next fit never uses more than $2M – 1$ bins.  There exist sequences such that next fit uses $2M  – 1$ bins.<br><strong>Analysis For Next Fit Algorithm:</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-16%20134541.png" alt=""></p>
<h5 id="Solution-2-First-Fit-Algorithm"><a href="#Solution-2-First-Fit-Algorithm" class="headerlink" title="Solution 2:First Fit Algorithm"></a>Solution 2:First Fit Algorithm</h5><pre><code class="lang-C">void FirstFit ( )
&#123;   while ( read item ) &#123;
        scan for the first bin that is large enough for item;
        if ( found )
    place item in that bin;
        else
    create a new bin for item;
    &#125; /* end-while */
&#125;
</code></pre>
<p><strong>【Theorem】</strong> Let $M$ be the optimal number of bins required to pack a list $I$ of items.  Then first fit never uses more than $17M / 10$ bins.  There exist sequences such that first fit uses $17(M – 1) / 10$ bins.</p>
<h5 id="Solution-3-Best-Fit-Algorithm"><a href="#Solution-3-Best-Fit-Algorithm" class="headerlink" title="Solution 3:Best Fit Algorithm"></a>Solution 3:Best Fit Algorithm</h5><pre><code class="lang-C">void BestFit ( )
&#123;   while ( read item ) &#123;
        scan for the bin that is large enough for item and Place it in the tightest spot;
        if ( found )
    place item in that bin;
        else
    create a new bin for item;
    &#125; /* end-while */
&#125;
</code></pre>
<p><strong>【Theorem】</strong> $T = O( N log N )$ and bin $no. ≤ 1.7M$  </p>
<h4 id="Online-Algorithms"><a href="#Online-Algorithms" class="headerlink" title="Online Algorithms"></a>Online Algorithms</h4><h5 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h5><p>Place an item before processing the next one, and can <strong>NOT</strong> change decision.</p>
<h4 id="Offline-Algorithms"><a href="#Offline-Algorithms" class="headerlink" title="Offline Algorithms"></a>Offline Algorithms</h4><h5 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h5><p>Place an item after processing all input items, and <strong>can</strong> change decision.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-16%20141905.png" alt=""></p>
<h4 id="KnapSack-Problem"><a href="#KnapSack-Problem" class="headerlink" title="KnapSack Problem"></a>KnapSack Problem</h4><h5 id="Definition-of-fractional-knapsack-problem"><a href="#Definition-of-fractional-knapsack-problem" class="headerlink" title="Definition of fractional knapsack problem"></a>Definition of fractional knapsack problem</h5><p>Given a set of $n$ items, where item $i$ has a size $s_i$ and a value $v_i$ , and a knapsack of size $S$ , find a subset of the items that maximizes the total value of the items in the knapsack, subject to the constraint that the sum of the sizes of the items in the knapsack is at most $S$ .  We call this the fractional knapsack problem because we are allowed to take fractions of items.</p>
<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><pre><code class="lang-C">void FractionalKnapsack ( )
&#123;   sort the items in decreasing order of value per unit size;
    while ( there is room in the knapsack ) &#123;
        place the next item in the knapsack;
    &#125; /* end-while */
&#125;
</code></pre>
<p><strong>【Theorem】</strong> The greedy algorithm for the fractional knapsack problem has an approximation ratio of 2.</p>
<h5 id="Definition-of-0-1-knapsack-problem"><a href="#Definition-of-0-1-knapsack-problem" class="headerlink" title="Definition of 0-1 knapsack problem"></a>Definition of 0-1 knapsack problem</h5><p>Given a set of $n$ items, where item $i$ has a size $s_i$ and a value $v_i$ , and a knapsack of size $S$ , find a subset of the items that maximizes the total value of the items in the knapsack, subject to the constraint that the sum of the sizes of the items in the knapsack is at most $S$ .  We call this the 0-1 knapsack problem because we are not allowed to take fractions of items.</p>
<h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h5><pre><code class="lang-C">void ZeroOneKnapsack ( )
&#123;   for ( i = 0; i &lt; n; i++ )
        for ( j = 0; j &lt;= S; j++ )
            if ( s_i &gt; j )
                M[i][j] = M[i – 1][j];
            else
                M[i][j] = max( M[i – 1][j], M[i – 1][j – s_i] + v_i );
&#125;
</code></pre>
<p><strong>【Theorem】</strong> The dynamic programming algorithm for the 0-1 knapsack problem runs in time $O(nS)$ and has an approximation ratio of 2.</p>
<p><strong>【Proof】</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-16%20143032.png" alt=""></p>
<h4 id="The-K-Center-Problem"><a href="#The-K-Center-Problem" class="headerlink" title="The K-Center Problem"></a>The K-Center Problem</h4><h5 id="Definition-7"><a href="#Definition-7" class="headerlink" title="Definition"></a>Definition</h5><p>Given a set of $n$ points $P = {p_1 , p_2 , …, p_n }$ in a metric space, find a set of $k$ points $C = {c_1 , c_2 , …, c_k }$ such that the maximum distance from any point in $P$ to its nearest center in $C$ is minimized.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/k-center.png" alt=""></p>
<h5 id="Solution-1-Greedy-2r-Algorithm"><a href="#Solution-1-Greedy-2r-Algorithm" class="headerlink" title="Solution 1:Greedy-2r Algorithm"></a>Solution 1:Greedy-2r Algorithm</h5><pre><code class="lang-C">Centers  Greedy-2r ( Sites S[ ], int n, int K, double r )
&#123;   Sites  S’[ ] = S[ ]; /* S’ is the set of the remaining sites */
    Centers  C[ ] = empty;
    while ( S’[ ] != empty ) &#123;
        Select any s from S’ and add it to C;
        Delete all s’ from S’ that are at dist(s’, s) &lt;= 2r;
    &#125; /* end-while */
    if ( |C| &lt;= K ) return C;
    else ERROR(No set of K centers with covering radius at most r);
&#125;
</code></pre>
<p><strong>【Theorem】</strong> Suppose the algorithm selects more than $K$ centers.  Then for any set $C^<em>$ of size at most $K$, the covering radius is $r(C^</em>) &gt; r$.</p>
<h5 id="Solution-2-Greedy-r-Algorithm"><a href="#Solution-2-Greedy-r-Algorithm" class="headerlink" title="Solution 2:Greedy-r Algorithm"></a>Solution 2:Greedy-r Algorithm</h5><pre><code class="lang-C">Centers  Greedy-Kcenter ( Sites S[ ], int n, int K )
&#123;   Centers  C[ ] = empty;
    Select any s from S and add it to C;
    while ( |C| &lt; K ) &#123;
        Select s from S with maximum dist(s, C);
        Add s it to C;
    &#125; /* end-while */
    return C;
&#125;
</code></pre>
<p><strong>【Theorem】</strong> The algorithm returns a set C of $K$ centers such that $r(C) \leq 2r(C^<em>)$ where $C^</em>$ is an optimal set of $K$ centers.</p>
<h3 id="Exercises-3"><a href="#Exercises-3" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-4"><a href="#Judgement-4" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>An approximation scheme that runs in $O(n^2/ϵ)$ for any fixed $ϵ&gt;0$ is a fully polynomial-time approximation scheme.<blockquote>
<p>True<br>只要是n是多项式级别的就可以。</p>
</blockquote>
</li>
<li>An approximation scheme that runs in $O(n^23^ϵ)$ for any fixed $ϵ&gt;0$ is a polynomial-time approximation scheme.<blockquote>
<p>True<br>只要是n是多项式级别的就可以。</p>
</blockquote>
</li>
<li>As we know there is a 2-approximation algorithm for the Vertex Cover problem. Then we must be able to obtain a 2-approximation algorithm for the Clique problem, since the Clique problem can be polynomially reduced to the Vertex Cover problem.<blockquote>
<p>True<br>reduce to 就算&lt;=，如果CP&lt;=VC, VC有近似比为2的算法，那么CP也有</p>
</blockquote>
</li>
<li>An (1+ϵ)-approximation scheme of time complexity$(n+1/ϵ)^3$ is a PTAS but not an FPTAS.<blockquote>
<p>True<br>只有$ \epsilon $也固定了才是FPTAS</p>
</blockquote>
</li>
<li>For the 0-1 version of the Knapsack problem, if we are greedy on taking the maximum profit or profit density, then the resulting profit must be bounded below by the optimal solution minus the maximum profit.<blockquote>
<p>True<br>Popt&lt;Pfrac&lt;Pgre+pmax，最优解一定小于物体可分情况下的解。而物体可分情况下的解，可以看成greedy的解+一部分不完整的物体。不完整的物体权值一定小于最大权值。</p>
<h4 id="Choose-the-correct-answer-8"><a href="#Choose-the-correct-answer-8" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4></blockquote>
</li>
<li>For the bin-packing problem: let $S=∑S_i$. Which of the following statements is FALSE?<br>A.The number of bins used by the next-fit heuristic is never more than $⌈2S⌉$<br>B.The number of bins used by the first-fit heuristic is never more than $⌈2S⌉$<br>C.The next-fit heuristic leaves at most one bin less than half full<br>D.The first-fit heuristic leaves at most one bin less than half full<blockquote>
<p><strong>Answer: A</strong><br>NF近似比是2，其他的近似比都比2小。Next fit可能有多个半空的bit，因为如果永远往前放，不会回头放之前的，所以是C，而FF会检查之前所有位，因此如果有两个半空的，它们会放在一起。</p>
</blockquote>
</li>
<li>To approximate a maximum spanning tree $T$ of an undirected graph $G=(V,E)$ with distinct edge weights $w(u,v)$ on each edge $(u,v)∈E$, let’s denote the set of maximum-weight edges incident on each vertex by $S$. Also let $w(E′)=∑​(u,v)∈E​′$​​， $w(u,v)$ for any edge set $E′$. Which of the following statements is TRUE?<br>A.$S=T$ for any graph $G$<br>B.$S≠T$ for any graph $G$<br>C.$w(T)≥w(S)/2$ for any graph $G$<br>D.None of the above<blockquote>
<p><strong>Answer: C</strong><br>题目的意思是，如果把每个点最大权值的边加入一个集合，那么这个集合的权值和最大生成树权值之比是多少。注意，点的最大权值边集合意味着集合里相同的边最多出现一次。<br>很容易证明，$S$里面不存在环，因此$T$一定包含$S$.所以$w(T)&gt;=w(S)$<br>假如存在环，设边为$e_1,e_2,e_3,…e_j$, 点为$p_1, …p_j$<br>由于$e_1$在$S$中，因此$w(e_1)&gt;w(e-j)$，由于$e_2$在$S$中，因此$w(e_2)&gt;w(e_1),…$，最后得到的是$w(e_j)&gt;w(e_1)$，矛盾。</p>
</blockquote>
</li>
</ol>
<h2 id="Local-Search"><a href="#Local-Search" class="headerlink" title="Local Search"></a>Local Search</h2><h3 id="Definition-8"><a href="#Definition-8" class="headerlink" title="Definition"></a>Definition</h3><p>A <strong>local search</strong> algorithm starts with an initial solution and then tries to improve it by making small changes to it.  The algorithm terminates when it reaches a solution that cannot be improved by making small changes.</p>
<h4 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h4><ul>
<li>Define neighborhoods in the feasible set</li>
<li>A local optimum is a best solution in a neighborhood</li>
</ul>
<h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><ul>
<li>Start with a feasible solution and search a better one within the neighborhood</li>
<li>A local optimum is achieved if no improvement is possible</li>
</ul>
<h4 id="Neighbor-Relation"><a href="#Neighbor-Relation" class="headerlink" title="Neighbor Relation"></a>Neighbor Relation</h4><p>$S$~$S’$ : $S’$ is a neighboring solution of $S – S’$ can be obtained by a small modification of $S$.<br>$N(S)$: neighborhood of $S$ – the set ${ S’: S $ ~  $ S’ }$.</p>
<h3 id="Vertex-Cover-Problem"><a href="#Vertex-Cover-Problem" class="headerlink" title="Vertex Cover Problem"></a>Vertex Cover Problem</h3><h4 id="Definition-9"><a href="#Definition-9" class="headerlink" title="Definition"></a>Definition</h4><p>Given an undirected graph $G = (V, E)$.  Find a minimum subset $S$ of  $V$ such that for each edge $(u, v)$ in $E$, either $u$ or $v$  is in $S$.</p>
<h4 id="Bad-Cases"><a href="#Bad-Cases" class="headerlink" title="Bad Cases"></a>Bad Cases</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-23%20142155.png" alt=""></p>
<h4 id="Solution-Metroplis"><a href="#Solution-Metroplis" class="headerlink" title="Solution(Metroplis)"></a>Solution(Metroplis)</h4><pre><code class="lang-C">SolutionType Metropolis()
&#123;   Define constants k and T;
    Start from a feasible solution S in FS ;
    MinCost = cost(S);
    while (1) &#123;
        S’ = Randomly chosen from N(S); 
        CurrentCost = cost(S’);
        if ( CurrentCost &lt; MinCost ) &#123;
            MinCost = CurrentCost;    S = S’;
        &#125;
        else &#123;
            With a probability e^-(cost/KT) , let S = S’;
            else  break;
        &#125;
    &#125;
    return S;
&#125;
</code></pre>
<h3 id="Simulated-Annealing-Metroplis-Algorithm"><a href="#Simulated-Annealing-Metroplis-Algorithm" class="headerlink" title="Simulated Annealing(Metroplis Algorithm)"></a>Simulated Annealing(Metroplis Algorithm)</h3><h4 id="Definition-10"><a href="#Definition-10" class="headerlink" title="Definition"></a>Definition</h4><p>Simulated annealing is a probabilistic technique for approximating the global optimum of a given function. Specifically, it is a metaheuristic to approximate global optimization in a large search space for an optimization problem. It is often used when the search space is discrete (e.g., all tours that visit a given set of cities).</p>
<h4 id="Hopfield-Neural-Networks"><a href="#Hopfield-Neural-Networks" class="headerlink" title="Hopfield Neural Networks"></a>Hopfield Neural Networks</h4><h5 id="Definition-11"><a href="#Definition-11" class="headerlink" title="Definition"></a>Definition</h5><p>Graph $G = (V, E)$ with integer edge weights $w$ (positive or negative).<br>If $w_e &lt; 0$, where $e = (u, v)$, then $u$ and $v$ want to have the same state;if $w_e&gt; 0$  then $u$ and $v$ want different states.<br>The absolute value $|w_e|$ indicates the strength of this requirement.<br>Output: A configuration $S$ of the network – an assignment of the state $s_u$ to each node $u$<br><em>There may be no configuration that respects the requirements imposed by all the edges.</em><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20100003.png" alt=""></p>
<h5 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><pre><code class="lang-C">ConfigType State_flipping()
&#123;
    Start from an arbitrary configuration S;
    while ( ! IsStable(S) ) &#123;
        u = GetUnsatisfied(S);
        su = - su;
    &#125;
    return S;
&#125;
</code></pre>
<h5 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20100237.png" alt=""></p>
<h5 id="Claim"><a href="#Claim" class="headerlink" title="Claim"></a>Claim</h5><p>Any local maximum in the state-flipping algorithm to maximize $\Phi $ is a stable configuration.<br><strong>Is it a polynomial time algorithm?</strong><br>Still an open question: to find an algorithm that constructs stable states in time polynomial in $n$ and $logW$ (rather than $n$ and $W$), or in a number of primitive arithmetic operations that is polynomial in $n$ alone, independent of the value of $W$.</p>
<h4 id="The-Max-Cut-Problem"><a href="#The-Max-Cut-Problem" class="headerlink" title="The Max-Cut Problem"></a>The Max-Cut Problem</h4><h5 id="Definition-12"><a href="#Definition-12" class="headerlink" title="Definition"></a>Definition</h5><p>Given an undirected graph $G = (V, E)$.  Find a subset $S$ of $V$ such that the weight of edges $(u, v)$ in $E$ with $u \in S$ and $v \notin S$ is maximized.</p>
<h5 id="How-good-is-the-Local-Optimum"><a href="#How-good-is-the-Local-Optimum" class="headerlink" title="How good is the Local Optimum?"></a>How good is the Local Optimum?</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20101517.png" alt=""></p>
<h3 id="A-better-local-search-algorithm"><a href="#A-better-local-search-algorithm" class="headerlink" title="A better local search algorithm"></a>A better local search algorithm</h3><ul>
<li>The neighborhood of a solution should be rich enough that we do not tend to get stuck in bad local optima; </li>
<li>but the neighborhood of a solution should not be too large, since we want to be able to efficiently search the set of neighbors for possible local moves.</li>
</ul>
<h4 id="Kernighan-Lin-heuristic"><a href="#Kernighan-Lin-heuristic" class="headerlink" title="Kernighan-Lin heuristic"></a>Kernighan-Lin heuristic</h4><p>Single-flip -&gt; k-flip $\Theta(n^k)$ for searching in neighbors</p>
<h3 id="Exercises-4"><a href="#Exercises-4" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-5"><a href="#Judgement-5" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>Greedy method is a special case of local search.<blockquote>
<p>False<br>Greedy是不断前进，最后达到解。而local search是不断修改值，选择一个最佳的解。求出的每一个解都是最终的解。</p>
</blockquote>
</li>
<li>For the graph given in the following figure, if we start from deleting the black vertex, then local search can always find the minimum vertex cover.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/150.png" alt=""><blockquote>
<p>True<br>一个点可以删除的条件是：这条边的另一个点没有被删除。如果可以删除，则任意删除一个。如果不能删除，则算法结束。剩下的点越少越好。<br>如果删除黑点，那么不能删除右边的点，也不能删除下面的点，只能删除最下面两个。因此确实达到了最优解。</p>
</blockquote>
</li>
<li>Since finding a locally optimal solution is presumably easier than finding an optimal solution, we can claim that for any local search algorithm, one step of searching in neighborhoods can always be done in polynomial time.<blockquote>
<p>False<br>PPT上说Local Search是不是一个多项式时间算法还是未知的。</p>
</blockquote>
</li>
<li>In local search, if the optimization function has a constant value in a neighborhood, there will be a problem.<blockquote>
<p>True<br>说明到了一个低谷或者山峰。或者平衡状态。需要随机选择一个转移。</p>
</blockquote>
</li>
<li><p>Random restarts can help a local search algorithm to better find global maxima that are surrounded by local maxima.</p>
<blockquote>
<p>True<br>算法如果到达local maxiam就停止了，但是如果随机开始，那么可能会到达local maxiam和global maxium之间，然后找到全局最优。</p>
</blockquote>
</li>
<li><p>In Metropolis Algorithm, the probability of jumping up depends on T, the temperature. When the temperature is high, it’ll be close to the original gradiant descent method.</p>
<blockquote>
<p>True<br>温度高的时候会跳跃，温度低的时候接近下降算法。</p>
</blockquote>
</li>
<li><p>Local search algorithm can be used to solve lots of classic problems, such as SAT and N-Queen problems. Define the configuration of SAT to be X = vector of assignments of $N$ boolean variables, and that of N-Queen to be Y = positions of the $N$ queens in each column. The sizes of the search spaces of SAT and N-Queen are $O(2^N)$ and $O(N^N)$,respectively.</p>
<blockquote>
<p>True<br>搜索空间指的是所有可能。虽然$N$皇后准确来说应该是$N!$</p>
</blockquote>
</li>
<li><p>We are given a set of sites $S=${$s<em>1,s</em>​2,…,s<em>​n​​$} in the plane, and we want to choose a set of $k$ centers $C$={$c_1, c</em>​2,⋯,c_​k$} so that the maximum distance from a site to the nearest center is minimized. Here ci can be an arbitrary point in the plane.<br>A local search algorithm arbitrarily choose $k$ points in the plane to be the centers, then<br>(1) divide $S$ into $k$ sets, where $S_i$ is the set of all sites for which $c_i$ is the nearest center; and<br>(2) for each $S_i$, compute the central position as a new center for all the sites in Si.<br>If steps (1) and (2) cause the covering radius to strictly decrease, we perform another iteration, otherwise the algorithm stops.<br>When the above local search algorithm terminates, the covering radius of its solution is at most 2 times the optimal covering radius.</p>
<blockquote>
<p>False<br>原因在于K center近似比不能低于2.否则P=NP，K center可以规约为r=1的Vertex Cover问题。</p>
<h4 id="Choose-the-correct-answer-9"><a href="#Choose-the-correct-answer-9" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4></blockquote>
</li>
<li>A bipartite graph $G$ is one whose vertex set can be partitioned into two sets $A$ and $B$, such that each edge in the graph goes between a vertex in $A$ and a vertex in $B$. Matching $M$ in $G$ is a set of edges that have no end points in common. Maximum Bipartite Matching Problem finds a matching with the greatest number of edges (over all matching).<br>Consider the following Gradient Ascent Algorithm:<br><code>As long as there is an edge whose endpoints are unmatched, add it to the current matching. When there is no longer such an edge, terminate with a locally optimal matching.</code><br>Let $M_1$ and $M_2$ be matchings in a bipartite graph $G$. Which of the following statements is true?<br>A.This gradient ascent algorithm never returns the maximum matching.<br>B.Suppose that $∣M_1∣&gt;2∣M_2∣$. Then there must be an edge $e$ in $M_1$  such that $M_2 ∪ {e}$ is a matching in $G$.<br>C.Any locally optimal matching returned by the gradient ascent algorithm in a bipartite graph $G$ is at most half as large as a maximum matching in $G$.<br>D.All of the above<blockquote>
<p>B</p>
</blockquote>
</li>
</ol>
<h2 id="Randomized-Algorithms"><a href="#Randomized-Algorithms" class="headerlink" title="Randomized Algorithms"></a>Randomized Algorithms</h2><h3 id="Definition-13"><a href="#Definition-13" class="headerlink" title="Definition"></a>Definition</h3><p>The algorithm behaves randomly – <strong>make random decisions</strong> as the algorithm processes the <strong>worst-case</strong> input.<br>$Pr[ A ]$ := the probability of the even A<br>$\overline{A}$:= the complementary of the event $A$ ($A$ did not occur )<br>$E[ X ]$ := the expectation (the “average value”) of the random variable $X$<br>$E[ X ] = \sum_{i=1}^{n} x_i Pr[ X = x_i ]$</p>
<h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Hiring-Problem"><a href="#Hiring-Problem" class="headerlink" title="Hiring Problem"></a>Hiring Problem</h4><h5 id="Definition-14"><a href="#Definition-14" class="headerlink" title="Definition"></a>Definition</h5><p>Given a set of $n$ applicants, select the best one.  The applicants are interviewed one by one in a random order.  After each interview, the applicant is either hired or rejected.  If the applicant is hired, the process stops.  Otherwise, the next applicant is interviewed.  The goal is to maximize the probability of hiring the best applicant.</p>
<p><strong>Interviewing cost</strong> $c_i$ for each applicant $i$.<br><strong>Hire cost</strong> $c_h$ for each applicant $i$.<br>Assume that $c_i$ &lt;&lt; $c_h$ for all $i$.</p>
<h5 id="Solution-Naive"><a href="#Solution-Naive" class="headerlink" title="Solution Naive"></a>Solution Naive</h5><pre><code class="lang-C">int Hiring ( EventType C[ ], int N )
&#123;   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;
    for ( i=1; i&lt;=N; i++ ) &#123;
        Qi = interview( i ); /* Ci */
        if ( Qi &gt; BestQ ) &#123;
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        &#125;
    &#125;
    return Best;
&#125;
</code></pre>
<p><strong>Worst Case:</strong> The candidates come in increasing quality order.$O(nC_h)$</p>
<h5 id="Solution-Randomized"><a href="#Solution-Randomized" class="headerlink" title="Solution Randomized"></a>Solution Randomized</h5><pre><code class="lang-C">int RandomizedHiring ( EventType C[ ], int N )
&#123;   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;

    randomly permute the list of candidates;

    for ( i=1; i&lt;=N; i++ ) &#123;
        Qi = interview( i ); /* Ci */
        if ( Qi &gt; BestQ ) &#123;
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        &#125;
    &#125;
</code></pre>
<p>But how to generate a random permutation?</p>
<pre><code class="lang-C">void PermuteBySorting ( ElemType A[ ], int N )
&#123;
    for ( i=1; i&lt;=N; i++ )
        A[i].P = 1 + rand()%(N3); 
        /* makes it more likely that all priorities are unique */
    Sort A, using P as the sort keys;
&#125;
</code></pre>
<p><strong>Claim:</strong> Permute By Sorting produces a uniform random permutation of the input, assuming all priorities are distinct.</p>
<p><strong>Cost:</strong> $O(C_hlogN+NC_i)$<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-05-30%20135238.png" alt=""><br>Note that the possibliity of hiring the $i$th candidate is $1/i$,because the $i$th candidate must be the best one among the first $i$ candidates.</p>
<h4 id="Online-Hiring-Problem"><a href="#Online-Hiring-Problem" class="headerlink" title="Online Hiring Problem"></a>Online Hiring Problem</h4><pre><code class="lang-C">int OnlineHiring ( EventType C[ ], int N, int k )
&#123;
    int Best = N;
    int BestQ = - infinete ;
    for ( i=1; i&lt;=k; i++ ) &#123;
        Qi = interview( i );
        if ( Qi &gt; BestQ )   BestQ = Qi;
    &#125;
    for ( i=k+1; i&lt;=N; i++ ) &#123;
        Qi = interview( i );
        if ( Qi &gt; BestQ ) &#123;
            Best = i;
            break;
        &#125;
    &#125;
    return Best;
&#125;
</code></pre>
<h4 id="Randomized-Quick-Sort"><a href="#Randomized-Quick-Sort" class="headerlink" title="Randomized Quick Sort"></a>Randomized Quick Sort</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20113109.png" alt=""></p>
<h3 id="Exercises-5"><a href="#Exercises-5" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-6"><a href="#Judgement-6" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>Randomized algorithms are for solving the problems with randomly generated inputs.<blockquote>
<p>False<br>随机算法是为了解决最坏情况下的输入。</p>
</blockquote>
</li>
<li>The worst-case running time is equal to the expected running time within constant factors for any randomized algorithm.<blockquote>
<p>False<br>快速排序的最坏情况是$O(n^2)$，但是期望时间是$O(nlogn)$</p>
</blockquote>
</li>
<li><p>Let $a=(a<em>1,a​_2,…,a</em>​i,…,a<em>j,…,a_n)$ denote the list of elements we want to sort. In the quicksort algorithm, if the pivot is selected uniformly at random. Then any two elements get compared at most once and the probability of $a_i$ and $a</em>​j$ being compared is $2/(j−i+1)$ for $j&gt;i$, given that $a_i$ or $a_j$ is selected as the pivot.</p>
<blockquote>
<p>False<br>假如有4个元素，第3个被选中。如果$a_1&gt;a_3$, $a_4<a_3$, 那么$a_1$和$a_4$发生交换，然后算法就停止了，不会比较$a_2$和$a_3$，此时而$a_1>a_3$概率为$1/2$，$a_4&lt;a_3$的概率为$1/2$, 因此概率为$1/4$。</p>
</blockquote>
</li>
<li><p>Reviewing the randomized QuickSort in our course, we always select a central splitter as a pivot before recursions, make sure that each side contains at least $n/4$ elements. Hence, differing from the deterministic QuickSort, the worst case expected running time of the randomized QuickSort is $Θ(NlogN)$.</p>
<blockquote>
<p>True<br>由于每次都选择中间的元素作为pivot，因此每次都会将数组分成两部分，每部分的元素个数都是原来的一半，因此递归的深度为$O(logn)$，每次递归的时间复杂度为$O(n)$，因此总的时间复杂度为$\Theta (nlogn)$</p>
<h4 id="Choose-the-correct-answer-10"><a href="#Choose-the-correct-answer-10" class="headerlink" title="Choose the correct answer"></a>Choose the correct answer</h4></blockquote>
</li>
<li>If we repeatedly perform independent trials of an experiment, each of which succeeds with probability $p&gt;0$, then the expected number of trials we need to perform until the first success is:<br>A.$p/(1−p)$<br>B.$1/(1−p)$<br>C.$1/p$<br>D.None of the above<blockquote>
<p><strong>Answer:C</strong><br>如果我们反复进行独立试验，每次试验成功的概率为$p &gt; 0$，那么直到第一次成功需要进行的平均试验次数为：<br>使用几何分布的概念，可以计算直到第一次成功所需的平均试验次数。在几何分布中，我们关注的是在一系列独立伯努利试验中，需要多少次试验才能实现第一次成功，每次试验的成功概率为$p$。<br>第一次成功发生在第$k$次试验的概率由以下公式给出：<br>$P(X = k) = (1 - p)^{k-1} \cdot p$<br>在这里，$X$表示随机变量，表示直到第一次成功所需的试验次数。公式$(1 - p)^{k-1}$表示在第$k-1$次试验中发生$k-1$次失败，然后在第$k$次试验中发生一次成功的概率，$p$表示成功的概率。<br>几何分布的期望值或均值由成功概率的倒数给出：<br>$E(X) = \frac{1}{p}$<br>因此，直到第一次成功所需的平均试验次数为$1/p$。</p>
</blockquote>
</li>
<li>Given a 3-SAT formula with k clauses, in which each clause has three variables, the MAX-3SAT problem is to find a truth assignment that satisfies as many clauses as possible. A simple randomized algorithm is to flip a coin, and to set each variable true with probability $1/2$, independently for each variable. Which of the following statements is FALSE?<br>A.The expected number of clauses satisfied by this random assignment is $7k/8$.<br>B.For every instance of 3-SAT, there is a truth assignment that satisfies at least a $7/8$ fraction of all clauses.<br>C.If we repeatedly generate random truth assignments until one of them satisfies $≥7k/8$ clauses, then this algorithm is a 8/7-approximation algorithm.<br>D.The probability that a random assignment satisfies at least $7k/8$ clauses is at most $1/(8k)$.<blockquote>
<p><strong>Answer:D</strong><br>A. 这个陈述是正确的。根据随机算法，每个子句被满足的概率为$1/2^3 = 1/8$，因此对于k个子句，期望满足的子句数量为$(1/8) \cdot k = k/8$。因此，满足的子句数量的期望是$7k/8$，陈述A是正确的。<br>B. 这个陈述是正确的。根据随机算法，每个子句被满足的概率为$1/2^3 = 1/8$。对于一个3-SAT公式，每个子句有三个变量，因此共有$3k$个子句。期望满足的子句数量为$(1/8) \cdot 3k = 3k/8$。现在我们来考虑子句比例。最坏情况下，假设每个子句都有不同的变量组合，这意味着它们之间没有重叠的变量。在这种情况下，我们可以将至多$1/8$的子句满足为最差的情况。因此，我们可以保证至少有$1 - 1/8 = 7/8$的子句比例可以被满足。<br>C. 这个陈述是正确的。当我们重复生成随机真值赋值，直到其中一个满足$≥7k/8$个子句时，我们期望满足的子句数量为$7k/8$。因此，这个算法是一个$8/7$-近似算法，因为我们期望满足的子句数量是最优解（最大满足子句数）的$8/7$倍。<br>D. 这个陈述是错误的。根据概率的性质，至少满足$7k/8$个子句的概率应该大于等于每个子句独立满足的概率，即$1/8$。因此，满足至少$7k/8$个子句的概率最低为$1/8$，而不是$1/(8k)$。因此，陈述D是错误的。</p>
</blockquote>
</li>
<li>Given a linked list containg $N$ nodes. Our task is to remove all the nodes. At each step, we randomly choose one node in the current list, then delete the selected node together with all the nodes after it. Here we assume that each time we choose one node uniformly among all the remaining nodes. What is the expected number of steps to remove all the nodes?<br>A.$Θ(logN)$<br>B.$N/e$<br>C.$N/2$<br>D.$\sqrt{N}$<blockquote>
<p><strong>Answer:A</strong><br>删去当前节点需要1步，选择的节点可能是$N$个中任意一个，如果选择第$i$个，那么需要删除$N-i$个。$i$的范围是$1$到$N-1$因此复杂度为<br>$T ( N ) =  \frac 1N(T(1)+T(2)+…+T(N-1))+1$<br>如果是$N$的话，1无法消掉。而$logN$刚好可以消掉1</p>
</blockquote>
</li>
<li>The Online Hiring Algorithm ( hire only once ) is described as the following:<pre><code class="lang-c++">int OnlineHiring ( EventType C[ ], int N, int k )
&#123;
 int Best = N;
 int BestQ = -INFINITY ;
 for ( i=1; i&lt;=k; i++ ) &#123;
     Qi = interview( i );
     if ( Qi &gt; BestQ )   BestQ = Qi;
 &#125;
 for ( i=k+1; i&lt;=N; i++ ) &#123;
     Qi = interview( i );
     if ( Qi &gt; BestQ ) &#123;
         Best = i;
         break;
     &#125;
 &#125;
 return Best;
&#125;
</code></pre>
Assume that the quality input $C[ ]$ is uniformly random. When $N = 271$ and $k = 90$, the probability of hiring the $Nth$ candidate is__.<br>A.$1/e$<br>B.$1/N$<br>C.$1/3$<br>D.$1/k$<blockquote>
<p><strong>Answer:C</strong><br>要求雇佣第271个，因此前270个中，最好的必须落在前k个，就是前90个中，概率是90/270=1/3</p>
</blockquote>
</li>
</ol>
<h2 id="Parallel-Algorithms"><a href="#Parallel-Algorithms" class="headerlink" title="Parallel Algorithms"></a>Parallel Algorithms</h2><h3 id="Parallel-Random-Access-Machine-PRAM"><a href="#Parallel-Random-Access-Machine-PRAM" class="headerlink" title="Parallel Random Access Machine (PRAM)"></a>Parallel Random Access Machine (PRAM)</h3><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20145518.png" alt=""></p>
<h4 id="To-resolve-access-conflicts"><a href="#To-resolve-access-conflicts" class="headerlink" title="To resolve access conflicts"></a>To resolve access conflicts</h4><ul>
<li>Exclusive-Read Exclusive-Write (EREW)</li>
<li>Concurrent-Read Exclusive-Write (CREW)</li>
<li>Concurrent-Read Concurrent-Write (CRCW)<ul>
<li>Arbitrary rule</li>
<li>Priority rule (P with the smallest number)</li>
<li>Common rule (if all the processors are trying to write the same value)</li>
</ul>
</li>
</ul>
<h3 id="Example-The-summation-problem"><a href="#Example-The-summation-problem" class="headerlink" title="Example: The summation problem."></a>Example: The summation problem.</h3><h4 id="PRAM-Algorithm"><a href="#PRAM-Algorithm" class="headerlink" title="PRAM Algorithm"></a>PRAM Algorithm</h4><pre><code class="lang-c++">for Pi ,  1 &lt;= i &lt;= n  pardo
  B(0, i) := A( i )
  for h = 1 to log n do
    if i &lt;= n/2^h
      B(h, i) := B(h-1, 2i-1) + B(h-1, 2i)
    else stay idle
  for i = 1: output B(log n, 1); for i &gt; 1: stay idle
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20145937.png" alt=""></p>
<h4 id="Work-Depth-WD-Presentation"><a href="#Work-Depth-WD-Presentation" class="headerlink" title="Work-Depth (WD) Presentation"></a>Work-Depth (WD) Presentation</h4><pre><code class="lang-c++">for Pi ,  1 &lt;= i &lt;= n  pardo
   B(0, i) := A( i )
for h = 1 to log n 
    for Pi, 1 &lt;= i &lt;= n/2^h  pardo
        B(h, i) := B(h-1, 2i-1) + B(h-1, 2i)
for i = 1 pardo
   output  B(log n, 1)
</code></pre>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20150443.png" alt=""></p>
<h4 id="Measuring-the-Performance"><a href="#Measuring-the-Performance" class="headerlink" title="Measuring the Performance"></a>Measuring the Performance</h4><ul>
<li>Work load – total number of operations: $W(n)$</li>
<li>Worst-case running time: $T(n)$</li>
<li>$W(n)$ operations and $T(n)$ time<h5 id="Measuring-the-Performance-of-PRAM"><a href="#Measuring-the-Performance-of-PRAM" class="headerlink" title="Measuring the Performance of PRAM"></a>Measuring the Performance of PRAM</h5></li>
<li>$P(n) = W(n)/T(n)$ processors and $T(n)$ time (on a PRAM)</li>
<li>$W(n)/p$ time using any number of $p ≤ W(n)/T(n)$ processors (on a PRAM)</li>
<li>$W(n)/p + T(n)$ time using any number of $p $ processors (on a PRAM)<h5 id="Measuring-the-Performance-of-WD"><a href="#Measuring-the-Performance-of-WD" class="headerlink" title="Measuring the Performance of WD"></a>Measuring the Performance of WD</h5><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20151008.png" alt=""></li>
</ul>
<h3 id="Example-The-prefix-sum-problem"><a href="#Example-The-prefix-sum-problem" class="headerlink" title="Example: The prefix-sum problem"></a>Example: The prefix-sum problem</h3><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20151156.png" alt=""><br>$C(i,j)$的含义是：以$C(i,j)$为根的树，最右边的叶子加到$A(1)$的值<br>$B$是从下往上算，$C$是从上往下计算。</p>
<h4 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h4><pre><code class="lang-c++">for Pi , 1 &lt;= i &lt;= n pardo
  B(0, i) := A(i)
for h = 1 to log n
  for i , 1 &lt;= i &lt;= n/2^h pardo
    B(h, i) := B(h - 1, 2i - 1) + B(h - 1, 2i)
for h = log n to 0
  for i even, 1 &lt;= i &lt;= n/2^h pardo
    C(h, i) := C(h + 1, i/2)
  for i = 1 pardo
    C(h, 1) := B(h, 1)
  for i odd, 3 &lt;= i &lt;= n/2^h pardo
    C(h, i) := C(h + 1, (i - 1)/2) + B(h, i)
for Pi , 1 &lt;= i &lt;= n pardo
  Output C(0, i)
</code></pre>
<h4 id="Measuring-the-Performance-1"><a href="#Measuring-the-Performance-1" class="headerlink" title="Measuring the Performance"></a>Measuring the Performance</h4><p>$W(n) = O(N)$ and $T(n) =O( log n )$</p>
<h3 id="Example-Merging"><a href="#Example-Merging" class="headerlink" title="Example: Merging"></a>Example: Merging</h3><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20151845.png" alt=""><br>到A中每个元素在B中排名，B中每个元素在A中排名，在结果中的排名就是在A中排名+在B中排名。<br>因此，给了Rank，merge复杂度是$T(N)=O(1)$, $W(N)=O(N)$</p>
<h4 id="Algorithm-Binary-Search"><a href="#Algorithm-Binary-Search" class="headerlink" title="Algorithm: Binary Search"></a>Algorithm: Binary Search</h4><pre><code class="lang-c++">for Pi , 1 &lt;= i &lt;= n  pardo
    RANK(i, B) := BS(A(i), B)
    RANK(i, A) := BS(B(i), A)
</code></pre>
<p>$W(n) = O(N log N)$ and $T(n) = O(log N)$</p>
<h4 id="Algorithm-Serial-Ranking"><a href="#Algorithm-Serial-Ranking" class="headerlink" title="Algorithm: Serial Ranking"></a>Algorithm: Serial Ranking</h4><pre><code class="lang-c++">i = j = 0; 
while ( i &lt;= n || j &lt;= m ) &#123;
    if ( A(i+1) &lt; B(j+1) )
        RANK(++i, B) = j;
    else RANK(++j, A) = i;
&#125;
</code></pre>
<p>$W(n) = O(N+M)$ and $T(n) = O(N+M)$</p>
<h4 id="Parallel-Ranking"><a href="#Parallel-Ranking" class="headerlink" title="Parallel Ranking"></a>Parallel Ranking</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20152411.png" alt=""></p>
<h3 id="Example-Maximal-Finding"><a href="#Example-Maximal-Finding" class="headerlink" title="Example: Maximal Finding"></a>Example: Maximal Finding</h3><h4 id="Summation"><a href="#Summation" class="headerlink" title="Summation"></a>Summation</h4><p>和相邻的比较，大的进入上一层，最后时间一共$T(N)=O(logN)$，$W(N)=O(N)$</p>
<h4 id="All-Pairs"><a href="#All-Pairs" class="headerlink" title="All Pairs"></a>All Pairs</h4><pre><code class="lang-cpp">for Pi , 1 &lt;= i &lt;= n  pardo
    B(i) := 0
for i and j, 1 &lt;= i, j &lt;= n  pardo
    if ( (A(i) &lt; A(j)) || ((A(i) = A(j)) &amp;&amp; (i &lt; j)) )
            B(i) = 1
    else B(j) = 1
for Pi , 1 &lt;= i &lt;= n  pardo
    if B(i) == 0
       A(i) is a maximum in A
</code></pre>
<p>分为$N^2$个进程，每个进程做第$i$个和第$j$个比较，$j$是$i$后面任何一个, 将小的那个记录成1.<br>然后分成$N$个进程，每个进程检查这个元素是不是0，是0的就是最大元素。<br>$W(N)=N^2$, $T(N)=O(1)$</p>
<h4 id="A-Doubly-logarithmic-Paradigm"><a href="#A-Doubly-logarithmic-Paradigm" class="headerlink" title="A Doubly-logarithmic Paradigm"></a>A Doubly-logarithmic Paradigm</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20153019.png" alt=""></p>
<h5 id="按照-sqrt-N-进行分组"><a href="#按照-sqrt-N-进行分组" class="headerlink" title="按照$\sqrt N $进行分组"></a>按照$\sqrt N $进行分组</h5><p>$T(N)=O(loglogN)$, $W(N)=O(NloglogN)$</p>
<h5 id="按照-h-loglogN-进行分组"><a href="#按照-h-loglogN-进行分组" class="headerlink" title="按照$h=loglogN$进行分组"></a>按照$h=loglogN$进行分组</h5><p>$T(N)=O(loglogN)$, $W(N)=O(N)$</p>
<h5 id="按照-n-frac-78-分组"><a href="#按照-n-frac-78-分组" class="headerlink" title="按照$n^{\frac 78}$分组"></a>按照$n^{\frac 78}$分组</h5><p>$T(N)=O(1)$,$W(N)=O(N)$ </p>
<h3 id="Exercises-6"><a href="#Exercises-6" class="headerlink" title="Exercises"></a>Exercises</h3><h4 id="Judgement-7"><a href="#Judgement-7" class="headerlink" title="Judgement"></a>Judgement</h4><ol>
<li>EREW does not allow simultaneous access by more than one processor to the same memory location for read or write purposes.<blockquote>
<p>True<br>定义</p>
</blockquote>
</li>
<li>CREW allows concurrent access for reads but not for writes.<blockquote>
<p>True<br>定义</p>
</blockquote>
</li>
<li>CRCW allows concurrent access for both reads and writes.<blockquote>
<p>True<br>定义</p>
</blockquote>
</li>
<li>In Work-Depth presentation, each time unit consists of a sequence of instructions to be performed concurrently; the sequence of instructions may include any number.<blockquote>
<p>True</p>
<h4 id="Choose-the-Correct-Answer"><a href="#Choose-the-Correct-Answer" class="headerlink" title="Choose the Correct Answer"></a>Choose the Correct Answer</h4></blockquote>
</li>
<li>The prefix-min problem is to find for each $i$, $1≤i≤n$, the smallest element among $A(1)$, $A(2), ⋯, A(i)$. What is the run time and work load for the following algorithm?<pre><code class="lang-c++">for i, 1≤i≤n pardo
B(0, i) = A(i)
for h=1 to log(n)
for i, 1≤i≤n/2^h pardo
 B(h, i) = min &#123;B(h-1, 2i-1), B(h-1, 2i)&#125;
for h=log(n) to 0
for i even, 1≤i≤n/2^h pardo
 C(h, i) = C(h+1, i/2)
for i=1 pardo
 C(h, 1) = B(h, 1)
for i odd, 3≤i≤n/2^h pardo
 C(h, i) = min &#123;C(h + 1, (i - 1)/2), B(h, i)&#125;
for i, 1≤i≤n pardo
Output C(0, i)
</code></pre>
A.$O(n), O(n)$<br>B.$O(logn), O(logn)$<br>C.$O(logn), O(n)$<br>D.$O(n), O(logn)$<blockquote>
<p><strong>Answer:C</strong><br>首先时间复杂度看外侧有一个$logN$的循环，内部是$i$个进程并行，每个进程是$O(1)$，因此时间为$O(logN)$, work load是$n/2^h$级数求和，答案是$N$</p>
</blockquote>
</li>
<li>Which one of the following statements about the Maximum Finding problem is true?<br>A.There exists a serial algorithm with time complexity being $O(logN)$.<br>B. No parallel algorithm can solve the problem in $O(1)$ time.<br>C.When partitioning the problem into sub-problems and solving them in parallel, compared with $\sqrt{N}$, choosing $loglogN$ as the size of each sub-problem can reduce the work load and the worst-case time complexity.<br>D.Parallel random sampling algorithm can run in $O(1)$ time and $O(N)$ work with very high probability.<blockquote>
<p><strong>Answer:D</strong><br>A顺序算法至少是N, B肯定不对,all pairs和random都是T=O(1),C只能减少work load</p>
</blockquote>
</li>
</ol>
<h2 id="External-Sorting"><a href="#External-Sorting" class="headerlink" title="External Sorting"></a>External Sorting</h2><h3 id="Why-external-sorting"><a href="#Why-external-sorting" class="headerlink" title="Why external sorting?"></a>Why external sorting?</h3><ul>
<li>The data to be sorted is too large to fit in memory.<h3 id="The-Main-Cost-I-O"><a href="#The-Main-Cost-I-O" class="headerlink" title="The Main Cost: I/O"></a>The Main Cost: I/O</h3></li>
<li>The main cost of external sorting is the number of I/O operations.</li>
<li>The data stored in the disk is divided into blocks of size $B$.</li>
<li>We assume that the disk has infinite capacity and can only be accessed sequentially.</li>
<li>For instance,if we want to read in $N$ records, we need to read in $\lceil N/B \rceil$ blocks,the complexity is $O(N/B)$.</li>
</ul>
<h3 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h3><h4 id="Definition-15"><a href="#Definition-15" class="headerlink" title="Definition"></a>Definition</h4><ul>
<li>Divide the data into blocks of size $B$.</li>
<li>Sort each block in memory.</li>
<li>Merge the sorted blocks into a single sorted file.</li>
</ul>
<p><strong>Run:</strong> A sorted subsequence of the input file.<br><strong>Pass:</strong> A merge of two sorted files.<br>If we have $N$ records,and the internal memory can hold $M$ records, then the number of passes is $\lceil log_{2}(\lceil N/B \rceil) \rceil +1$.</p>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-13%20143035.png" alt=""><br>In the instance above, the $M$ is 3, thus we do 2-way merge.<br>What if we can do K-way merge?</p>
<h3 id="K-way-Merge"><a href="#K-way-Merge" class="headerlink" title="K-way Merge"></a>K-way Merge</h3><h4 id="The-maximum-number-of-K"><a href="#The-maximum-number-of-K" class="headerlink" title="The maximum number of K"></a>The maximum number of K</h4><p>To merge $K$ sorted files, we need to maintain a buffer of size $2K$ in memory.<br>Thus, we can get the value $K$:$K = \lfloor M/B \rfloor$.</p>
<h4 id="Use-2-1-Tapes-to-do-2-way-Merge"><a href="#Use-2-1-Tapes-to-do-2-way-Merge" class="headerlink" title="Use 2+1 Tapes to do 2-way Merge"></a>Use 2+1 Tapes to do 2-way Merge</h4><p><strong>Claim:</strong> : If the number of runs is a Fibonacci number $F<em>N$,then the best way to distribute them is to split them into $F</em>{N–1}$ and $F_{N–2}$.</p>
<p>However, if we split them into Fibonacci numbers, the number of passes will be increased. </p>
<h4 id="For-a-K-way-Merge"><a href="#For-a-K-way-Merge" class="headerlink" title="For a K-way Merge"></a>For a K-way Merge</h4><p><strong>Claim:</strong> : For a k-way merge,$F<em>{N}^{(K)} = F</em>{N–1}^{(K)} + F<em>{N–2}^{(K)} + … + F</em>{N–K}^{(K)}$k, where $F<em>{i}^{(K)} = 0$ for $ 0 \leq i \leq K-2$, and $F</em>{K-1}^{(K)} = 1$.</p>
<h3 id="Longer-Runs"><a href="#Longer-Runs" class="headerlink" title="Longer Runs"></a>Longer Runs</h3><p>How can generate longer runs?<br><strong>Replacement selection</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20163526.png" alt=""></p>
<h3 id="minimize-the-merge-time"><a href="#minimize-the-merge-time" class="headerlink" title="minimize the merge time"></a>minimize the merge time</h3><p><strong>Huffman Tree</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/ADS/屏幕截图%202023-06-29%20164212.png" alt=""></p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/custom/donate/AliPay.jpg"></li>
                <li class="wechat-code"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/custom/donate/WeChatPay.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
        
          
            <div class="post-nepre full next">
          
            <a href="/2023/06/09/OOP/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://gcore.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/OOP/cover.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/OOP/cover.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                OOP复习笔记</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "cufCqTylUQUH7Ez5kCgC3fbR-MdYXbMMI",
        appKey: "lychiSFCksLLUOndXBDAsg3A",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>



    <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
    <div id="waline"></div>
    <style>
    #waline textarea {
        box-sizing: border-box;
        background: url("https://gitee.com/cungudafa/source/raw/master/img/gif/Sitich/Sitich2.gif") 100% 100% no-repeat;
    }
    </style>
    <script>
        Waline({
              el: '#waline',
              serverURL: 'https://waline-j7soumapm-orwell-yu.vercel.app/',
              pageSize: '10',
              lang: 'zh-CN',
              requiredFields: ['nick','mail'], //设置必填项
              placeholder: 'Ciallo～(∠・ω &lt; )⌒☆',
              visitor: 'true',
              emoji: [
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo',
              ],
              avatar: 'mp',
              dark: 'auto',
            });
    </script>


      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="" class="profile gravatar"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio%20avatar.jpg" itemprop="image" alt="mio" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="" itemprop="url" rel="author">mio</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>一个CS蒟蒻</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Orwell-Yu<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2022</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://gcore.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://gcore.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

	<!--浏览器搞笑标题-->
<script src="https://cdn.jsdelivr.net/gh/Orwell-Yu/cdn@latest/js/hititle.js"></script>
	<!-- 🌸飘落 -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/fz6m/Private-web@1.2/js/custom/click.min.js"></script>
	<!-- 雪花飘落 -->
	<!-- <script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js"></script> -->
	<!-- // 文字 -->
<script src="https://cdn.jsdelivr.net/gh/Orwell-Yu/cdn@latest/js/my_click.js"></script>
	<!-- // 烟花 -->
<!-- <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/fireworks.js"></script> -->
	<!-- // 星星跟随坠落 -->
<script src="https://cdn.jsdelivr.net/gh/cungudafa/cdn@2.1.2/js/cursor.js"></script>
	<!-- // 爱心 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script>
	<!-- // 连线 -->
	<!-- <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>
	<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script> -->
	<!-- 样式二（飘动的彩带） -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js" type="text/javascript"></script>
	<!-- live2D -->
<script src="../../live2d_default/autoload.js"></script> 
  <!-- 背景切换
<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script> -->
<!-- 实时通信 -->

  <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f6b2a0b1.js","daovoice")
    daovoice('init', {
      app_id: "900fd0f3"
    });
    daovoice('update');
  </script>
  
  

  
    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">秋山澪の小站</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/Orwell-Yu" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://twitter.com/yu_zhewen" class="fa fa-twitter" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="hhttps://user.qzone.qq.com/1955026836" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/%E6%8A%80%E6%9C%AF/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/%E7%94%9F%E6%B4%BB/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%B5%84%E6%BA%90/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/%E9%9A%8F%E6%83%B3/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/%E6%82%A6%E8%AF%BB/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/%E5%9B%BE%E9%9B%86/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="7598981325"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>

 

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

