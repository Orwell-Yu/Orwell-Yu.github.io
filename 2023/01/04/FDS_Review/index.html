<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">FDS Review | mio的博客</title>
  
    <link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/hutaoicon.png">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "秋山澪の小站";
  mashiro_option.author_name = "小站";
  mashiro_option.site_url = "https://orwell-yu.github.io/";
  mashiro_option.v_appId = "cufCqTylUQUH7Ez5kCgC3fbR-MdYXbMMI";
  mashiro_option.v_appKey = "lychiSFCksLLUOndXBDAsg3A";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "http://iw233.cn/api/Random.php".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dot">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://orwell-yu.github.io/">
          <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>这是一个二次元的博客？</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/Orwell-Yu" target="_blank" class="social-github" title="github">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://space.bilibili.com/350209137?spm_id_from=333.1007.0.0" target="_blank" class="social-github" title="bilibili">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/bilibili.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/legend-67-50" target="_blank" class="social-github" title="zhihu">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://twitter.com/yu_zhewen" target="_blank" class="social-github" title="Twitter">
                    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/social/twitter.png">
                  </a>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">秋山澪の</span>
            <span class="shironeko">小站</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/资源/">
                          <i class="fa fa-cloud-download" aria-hidden="true"></i>
                          资源
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/图集/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    赞赏
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/cover.png);" src="https://gcore.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/cover.png">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      FDS Review</h1>
      <p class="entry-census">
        <span>
          <a href="">
            <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg">
          </a>
        </span>
        <span>
          <a href="">mio</a>
        </span>
        <span class="bull">
        ·</span>
        2023-1-4<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h2 id="Algorithm-Anlysis"><a href="#Algorithm-Anlysis" class="headerlink" title="Algorithm Anlysis"></a>Algorithm Anlysis</h2><h3 id="Space-Comlexity"><a href="#Space-Comlexity" class="headerlink" title="Space Comlexity"></a>Space Comlexity</h3><p>The space complexity of an algorithm or a computer program is the amount of memory space required to solve an instance of the computational problem as a function of characteristics of the input. It is the memory required by an algorithm until it executes completely.</p>
<h3 id="Time-Comlexity"><a href="#Time-Comlexity" class="headerlink" title="Time Comlexity"></a>Time Comlexity</h3><p>In computer science, the time complexity is the computational complexity that describes the amount of computer time it takes to run an algorithm. Time complexity is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that each elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm are taken to be related by a constant factor.</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="Abustrct-Data-Type"><a href="#Abustrct-Data-Type" class="headerlink" title="Abustrct Data Type"></a>Abustrct Data Type</h3><blockquote>
<p>【Definition】<br>An Abstract Data Type (ADT) is a data type that is organized in such a way that the specification on the objects and specification of the operations on the objects are separated from the representation of the objects and the implementation on the operations.</p>
</blockquote>
<h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><h4 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h4><pre><code class="C">#ifndef LLIST_H
#define LLIST_H

typedef void node_proc_fun_t(void*);
typedef int node_comp_fun_t(const void*, const void*);

typedef void LLIST_T;

LLIST_T *llist_new(int elmsize);
int llist_delete(LLIST_T *ptr);

int llist_node_append(LLIST_T *ptr, const void *datap);
int llist_node_prepend(LLIST_T *ptr, const void *datap);

int llist_travel(LLIST_T *ptr, node_proc_fun_t *proc);

void llist_node_delete(LLIST_T *ptr, node_comp_fun_t *comp, const void *key); 
void *llist_node_find(LLIST_T *ptr, node_comp_fun_t *comp, const void *key);

#endif
</code></pre>
<h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><blockquote>
<p>【Definition】<br>A stack is a Last-In-First-Out (LIFO) list, that is, an ordered list in which insertions and deletions are made at the top only.</p>
</blockquote>
<h4 id="Operations-amp-Implementations"><a href="#Operations-amp-Implementations" class="headerlink" title="Operations &amp; Implementations"></a>Operations &amp; Implementations</h4><h5 id="Operations"><a href="#Operations" class="headerlink" title="Operations:"></a>Operations:</h5><pre><code class="C">Int  IsEmpty( Stack S );
Stack CreateStack(); 
DisposeStack( Stack S ); //该函数销毁数组栈(释放数组空间与栈空间)，返回NULL指针
MakeEmpty( Stack S ); 
Push( ElementType X, Stack S ); 
ElementType Top( Stack S ); 
Pop( Stack S ); 
</code></pre>
<h5 id="Array-Implementation"><a href="#Array-Implementation" class="headerlink" title="Array Implementation:"></a>Array Implementation:</h5><pre><code class="C">struct  StackRecord {
    int Capacity ;              /* size of stack */
    int TopOfStack;          /* the top pointer */
    /* ++ for push, -- for pop, -1 for empty stack */
    ElementType *Array;    /* array for stack elements */
 } ; 
</code></pre>
<h5 id="Linked-List-Implemetation-with-Dummy"><a href="#Linked-List-Implemetation-with-Dummy" class="headerlink" title="Linked List Implemetation(with Dummy):"></a>Linked List Implemetation(with Dummy):</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20171518.jpg" alt></p>
<h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><h5 id="Balance-Symbols"><a href="#Balance-Symbols" class="headerlink" title="Balance Symbols"></a>Balance Symbols</h5><pre><code class="C">Algorithm {
    Make an empty stack S;
    while(read in a character c) {
        if(c is an opening symbol)
            Push(c, S);
        else if(c is a closing symbol) {
            if(S is empty)  { ERROR; exit; }
            else{  /* stack is okay */
                if (Top(S) doesn’t match c)  { ERROR, exit; }
                else Pop(S);
            }  /* end else-stack is okay */
        }  /* end else-if-closing symbol */
    } /* end while-loop */ 
    if (S is not empty)  ERROR;
}
</code></pre>
<h5 id="Postfix-Infix-Prefix-Evaluation"><a href="#Postfix-Infix-Prefix-Evaluation" class="headerlink" title="Postfix Infix Prefix Evaluation"></a>Postfix Infix Prefix Evaluation</h5><p><strong>Note:</strong></p>
<ul>
<li>The order of operands is the same in infix and postfix.</li>
<li>Operators with higher precedence appear before those with lower precedence.</li>
</ul>
<p><strong>With <code>()</code> Implementation:</strong></p>
<ol>
<li>Never pop a <code>(</code> from the stack except when processing a <code>)</code> .</li>
<li>Observe that when <code>(</code>  is not in the stack, its precedence is the highest; but when it is in the stack, its precedence is the lowest.  Define in-stack precedence and incoming precedence for symbols, and each time use the corresponding precedence for comparison. </li>
<li>括号入栈前优先级最高，入栈后优先级最低。<blockquote>
<p>Plz read DS03 PPT Page 7 for further.</p>
</blockquote>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><blockquote>
<p>【Definition】<br>A queue is a First-In-First-Out (FIFO) list, that is, an ordered list in which insertions take place at one end and deletions take place at the opposite end.</p>
</blockquote>
<h4 id="Operations-amp-Implementations-1"><a href="#Operations-amp-Implementations-1" class="headerlink" title="Operations &amp; Implementations"></a>Operations &amp; Implementations</h4><h5 id="Operations-1"><a href="#Operations-1" class="headerlink" title="Operations:"></a>Operations:</h5><pre><code class="C">int IsEmpty( Queue Q );
Queue CreateQueue( ); 
DisposeQueue( Queue Q ); 
MakeEmpty( Queue Q ); 
Enqueue( ElementType X, Queue Q ); 
ElementType  Front( Queue Q ); 
Dequeue( Queue Q ); 
</code></pre>
<h5 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations:"></a>Implementations:</h5><pre><code class="C">struct  QueueRecord {
 int Capacity ;   /* max size of queue */
 int Front;          /* the front pointer */
 int Rear;           /* the rear pointer */
 int Size;  /* Optional - the current size of queue */
 ElementType *Array;    /* array for queue elements */
} ; 
</code></pre>
<img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20182729.jpg" alt><blockquote>
<p>Learn more about queue plz read PPT DS03 Page 11</p>
</blockquote>
<h5 id="Circular-Queue"><a href="#Circular-Queue" class="headerlink" title="Circular Queue:"></a>Circular Queue:</h5>队列的入队、出队操作很简单。入队时，通过<code>rear</code>的位置判断队列是否已满。如果没有满，则将<code>rear</code>后移一位，将新元素放置在<code>rear</code>所在位置。出队时，也可以通过<code>rear</code>的位置判断队列是否为空。如果不空，则只需将<code>front</code>后移一位即可。 获取队头元素，判断队列不空，则只需返回<code>front</code>指向位置的元素即可。</li>
</ol>
<p>想像一下，通过出队操作将数据弹出队列后，<code>front</code>之前的空间还能够再次得到吗？不能。所以使用普通数组实现队列，就再也不能使用<code>front</code>之前的空间了，这会导致大量空间丢失。</p>
<p>为了解决这个问题，将普通数组换成循环数组。在循环数组中，末尾元素的下一个元素不是数组外，而是数组的头元素。这样就能够再次使用<code>front</code>之前的存储空间了。</p>
<p>为了规避环形队列的两种边界情况：空或者满时都有<code>rear-front=1</code>,我们让两者始终差1，即始终有一个空位。</p>
<h3 id="Complete-Binary-Tree-and-Heap"><a href="#Complete-Binary-Tree-and-Heap" class="headerlink" title="Complete Binary Tree and Heap"></a>Complete Binary Tree and Heap</h3><h4 id="Operations-and-Implementations"><a href="#Operations-and-Implementations" class="headerlink" title="Operations and Implementations"></a>Operations and Implementations</h4><p><strong>Operations</strong></p>
<pre><code class="C">PriorityQueue  Initialize( int MaxElements ); 
void  Insert( ElementType X, PriorityQueue H ); 
ElementType  DeleteMin( PriorityQueue H ); 
ElementType  FindMin( PriorityQueue H ); 
</code></pre>
<p><strong>Simple Implementations</strong><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20202216.jpg" alt></p>
<h3 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h3><h4 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition"></a>Definition</h4><blockquote>
<p>【Definition】<br>A binary tree with n nodes and height h is complete  iff  its nodes correspond to the nodes numbered from 1 to n in the perfect binary tree of height h.</p>
</blockquote>
<p>也就是说，叶子节点只可能在最大的两层出现，上一层不满不可能有下一层。</p>
<h4 id="Array-Representation"><a href="#Array-Representation" class="headerlink" title="Array Representation"></a>Array Representation</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20202340.jpg" alt><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/图片1.png" alt></p>
<h4 id="MinHeap-amp-MaxHeap"><a href="#MinHeap-amp-MaxHeap" class="headerlink" title="MinHeap &amp; MaxHeap"></a>MinHeap &amp; MaxHeap</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20202853.jpg" alt></p>
<h4 id="Implementations-1"><a href="#Implementations-1" class="headerlink" title="Implementations"></a>Implementations</h4><h5 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h5><pre><code class="C">PriorityQueue Initialize( int  MaxElements ) 
{ 
     PriorityQueue  H; 
     if ( MaxElements &lt; MinPQSize ) 
    return  Error( &quot;Priority queue size is too small&quot; ); 
     H = malloc( sizeof ( struct HeapStruct ) ); 
     if ( H ==NULL ) 
    return  FatalError( &quot;Out of space!!!&quot; ); 
     /* Allocate the array plus one extra for sentinel */ 
     H-&gt;Elements = malloc(( MaxElements + 1 ) * sizeof( ElementType )); 
     if ( H-&gt;Elements == NULL ) 
    return  FatalError( &quot;Out of space!!!&quot; ); 
     H-&gt;Capacity = MaxElements; 
     H-&gt;Size = 0; 
     H-&gt;Elements[ 0 ] = MinData;  /* set the sentinel */
     return  H; 
}
</code></pre>
<h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><pre><code class="C">/* H-&gt;Element[ 0 ] is a sentinel */ sentinel:dummy
void  Insert( ElementType  X,  PriorityQueue  H ) 
{ 
     int  i; 

     if ( IsFull( H ) ) { 
    Error( &quot;Priority queue is full&quot; ); 
    return; 
     } 

     for ( i = ++H-&gt;Size; H-&gt;Elements[ i / 2 ] &gt; X; i /= 2 ) 
    H-&gt;Elements[ i ] = H-&gt;Elements[ i / 2 ]; 

     H-&gt;Elements[ i ] = X; 
}
</code></pre>
<p>$T (N) = O ( log N )$</p>
<h5 id="DeleteMin"><a href="#DeleteMin" class="headerlink" title="DeleteMin"></a>DeleteMin</h5><pre><code class="C">ElementType  DeleteMin( PriorityQueue  H ) 
{ 
    int  i, Child; 
    ElementType  MinElement, LastElement; 
    if ( IsEmpty( H ) ) { 
         Error( &quot;Priority queue is empty&quot; ); 
         return  H-&gt;Elements[ 0 ];   } 
    MinElement = H-&gt;Elements[ 1 ];  /* save the min element */
    LastElement = H-&gt;Elements[ H-&gt;Size-- ];  /* take last and reset size */
    for ( i = 1; i * 2 &lt;= H-&gt;Size; i = Child ) {  /* Find smaller child */ 
         Child = i * 2; 
         if (Child != H-&gt;Size &amp;&amp; H-&gt;Elements[Child+1] &lt; H-&gt;Elements[Child]) 
           Child++;     
         if ( LastElement &gt; H-&gt;Elements[ Child ] )   /* Percolate one level */ 
           H-&gt;Elements[ i ] = H-&gt;Elements[ Child ]; 
         else     break;   /* find the proper position */
    } 
    H-&gt;Elements[ i ] = LastElement; 
    return  MinElement; 
}
</code></pre>
<p>$T (N) = O ( log N )$</p>
<h5 id="PercolateUp-amp-PercolateDown"><a href="#PercolateUp-amp-PercolateDown" class="headerlink" title="PercolateUp &amp; PercolateDown"></a>PercolateUp &amp; PercolateDown</h5><pre><code class="C">void PercolateUp( int p, PriorityQueue H ){
    int i;
    int x=H-&gt;Elements[p];
    for(i = p;H-&gt;Elements[i/2]&gt;x &amp;&amp; i&gt;0;i/=2){
        H-&gt;Elements[i]=H-&gt;Elements[i/2];
    }
    H-&gt;Elements[i]=x;
}
</code></pre>
<pre><code class="C">void PercolateDown( int p, PriorityQueue H ){
    int i;
    int child;
    int x=H-&gt;Elements[p];
    for(i = p;i*2&lt;=H-&gt;Size;i=child){
        child=i*2;
        if(child != H-&gt;Size &amp;&amp; H-&gt;Elements[child+1] &lt; H-&gt;Elements[child]){
            child++;
        }
        if(x&gt;H-&gt;Elements[child]){
            H-&gt;Elements[i]=H-&gt;Elements[child];
        }
        else{
            break;
        }
    }
    H-&gt;Elements[i]=x;
}
</code></pre>
<h3 id="Puzzles"><a href="#Puzzles" class="headerlink" title="Puzzles"></a>Puzzles</h3><h4 id="Judgment-and-Choice"><a href="#Judgment-and-Choice" class="headerlink" title="Judgment and Choice"></a>Judgment and Choice</h4><ol>
<li><p>Push 5 characters <code>ooops</code> onto a stack. In how many different ways that we can pop these characters and still obtain <code>ooops</code>?<br><code>5</code></p>
<blockquote>
<p>ooo出入栈顺序随意，之后push( p ),pop( p ),push( o ),pop( o )。注意出栈不能比入栈多。<br>可以入出入出入出，入出入入出出，入入出入出出，入入出出入出，入入入出出出，5个</p>
</blockquote>
</li>
<li><p>Suppose that an array of size 6 is used to store a circular queue, and the values of <code>front</code> and <code>rear</code> are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of <code>front</code> and <code>rear</code> be?</p>
<pre><code>A.2 and 0
</code></pre><h4 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h4><h5 id="7-1-Pop-Sequence"><a href="#7-1-Pop-Sequence" class="headerlink" title="7-1 Pop Sequence"></a>7-1 Pop Sequence</h5><p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
</li>
</ol>
<p><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<p><strong>Output Specification:</strong><br>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<p><strong>Sample Input:</strong></p>
<pre><code>5 7 5
1 2 3 4 5 6 7
3 2 1 7 5 6 4
7 6 5 4 3 2 1
5 6 4 3 7 2 1
1 7 6 5 4 3 2
</code></pre><p><strong>Solution</strong></p>
<pre><code class="C">#include&lt;stdio.h&gt;
void StackCheck(int m,int n,int a[]){
        int b[1000];
        int top=0,ptr=0,temp=1;
        while (ptr&lt;n) {
            if (temp==a[ptr] &amp;&amp; top&lt;m) {
                ptr++;
                temp++;
            }//模拟入栈和给出栈顶的数字相同
            else if(top&gt;0 &amp;&amp; b[top]==a[ptr]){
                top--;
                ptr++;
            }//模拟栈顶和给出栈顶的数字相同
            else if(top&lt;m-1 &amp;&amp; ptr&lt;n){
                b[++top]=temp;
                temp++;
            }//都不同，模拟入栈
            else{
                break;
            }
        }
        if (ptr&lt;n) printf(&quot;NO\n&quot;);//不可能的条件
        else printf(&quot;YES\n&quot;);
}
int main() {
    int m,n,k;
    scanf(&quot;%d %d %d&quot;,&amp;m,&amp;n,&amp;k);
    for (int i=0; i&lt;k; i++) {
        int a[1000];
        for (int j=0; j&lt;n; j++) {
            scanf(&quot;%d&quot;,&amp;a[j]);
        }
        StackCheck(m,n,a);
    }
    return 0;
}
</code></pre>
<p><strong>Sample Output:</strong></p>
<pre><code>YES
NO
NO
YES
NO
</code></pre><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition"></a>Definition</h3><blockquote>
<p>【Definition】<br>A tree is a collection of nodes.  The collection can be empty; otherwise, a tree consists of:<br>  (1)  a distinguished node r, called the root;<br>  (2)  and zero or more nonempty (sub)trees T1, …, Tk, each of whose roots are connected by a directed edge from r.</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20184212.jpg" alt><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20184633.jpg" alt><br>深度：从root算起<br>高度：从leaf算起</p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><h4 id="Turn-to-BiTree"><a href="#Turn-to-BiTree" class="headerlink" title="Turn to BiTree"></a>Turn to BiTree</h4><p>First, we need to transfer the tree into a BiTree.<br>要点：</p>
<p>从这棵树的根结点开始，从上到下，看每一个结点，把你正在看的结点的孩子放在左子树，兄弟放在右子树。</p>
<p>口诀：</p>
<ol>
<li>将节点的孩子 放在左子树；</li>
<li>将节点的兄弟 放在右子树。</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20185145.jpg" alt></p>
<h4 id="Implementation-of-a-BiTree"><a href="#Implementation-of-a-BiTree" class="headerlink" title="Implementation of a BiTree"></a>Implementation of a BiTree</h4><pre><code class="C">
</code></pre>
<h3 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h3><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>There is a picture to better understand tree trasval.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20190405.jpg" alt></p>
<h4 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h4><h5 id="inorder"><a href="#inorder" class="headerlink" title="inorder"></a>inorder</h5><h5 id="preorder"><a href="#preorder" class="headerlink" title="preorder"></a>preorder</h5><h5 id="postorder"><a href="#postorder" class="headerlink" title="postorder"></a>postorder</h5><h5 id="rebuild"><a href="#rebuild" class="headerlink" title="rebuild"></a>rebuild</h5><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/aHR0cHM6Ly9pbWcuaGFjcGFpLmNvbS9maWxlLzIwMTkvMDcvJUU4JUJGJTg3JUU3JUE4JThCLWY1NzRhNWJlLnBuZw.png" alt></p>
<pre><code class="C">Tree BuildMyTree(int inorder[],int postorder[],int n)
{
    Tree T;
    if(n==0){
        return NULL;
    }
    T=(Tree)malloc(sizeof(BiTree));
    if(n==1){
        T-&gt;Element=inorder[0];
        T-&gt;Left=NULL;
        T-&gt;Right=NULL;
        return T;
    }
    int left;
    int right;
    for(int i=0;i&lt;n;i++){
        if(inorder[i]==postorder[n-1]){
            left=i;
            break;
        }
    }
    right=n-left-1;
    T-&gt;Element=postorder[n-1];
    T-&gt;Left=BuildMyTree(inorder,postorder,left);
    T-&gt;Right=BuildMyTree(inorder+left+1,postorder+left,right);
    return T;
}
</code></pre>
<h3 id="Properties-of-Binary-Trees"><a href="#Properties-of-Binary-Trees" class="headerlink" title="Properties of Binary Trees"></a>Properties of Binary Trees</h3><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20194233.jpg" alt></p>
<h3 id="Threaded-BinaryTree"><a href="#Threaded-BinaryTree" class="headerlink" title="Threaded BinaryTree"></a>Threaded BinaryTree</h3><p>对于没有左或者右孩子的节点，我们根据线索二叉树的不同，让他们分别指向不同的遍历顺序中的前继节点或者后继节点，更大化地利用空间。<br>对于没有孩子又没有前/后继的节点，其线索为<code>NULL</code><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/v2-890ef1e99682f6ce51523ea9463a481d_r.jpg" alt><br>同时，为了知道左右子树到底是不是真的孩子还是线索二叉树的线索，还有两个布尔变量应该在结构体中申明。</p>
<h4 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="C">typedef  struct  ThreadedTreeNode  *PtrTo  ThreadedNode;
typedef  struct  PtrToThreadedNode  ThreadedTree;
typedef  struct  ThreadedTreeNode {
       int LeftThread;   /* if it is TRUE, then Left */
       ThreadedTree Left;      /* is a thread, not a child ptr.   */
       ElementType Element;
       int RightThread; /* if it is TRUE, then Right */
       ThreadedTree Right;    /* is a thread, not a child ptr.   */
}
</code></pre>
<h4 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h4><h4 id="Definition-4"><a href="#Definition-4" class="headerlink" title="Definition"></a>Definition</h4><blockquote>
<p>【Definition】<br>A binary search tree is a binary tree.  It may be empty.  If it is not empty, it satisfies the following properties:<br>(1)  Every node has a key which is an integer, and the keys are distinct.<br>(2)  The keys in a nonempty left subtree must be smaller than the key in the root of the subtree.<br>(3)  The keys in a nonempty right subtree must be larger than the key in the root of the subtree.<br>(4)  The left and right subtrees are also binary search trees.</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20194408.jpg" alt></p>
<h4 id="Operations-amp-Implementations-2"><a href="#Operations-amp-Implementations-2" class="headerlink" title="Operations &amp; Implementations"></a>Operations &amp; Implementations</h4><h5 id="Operations-2"><a href="#Operations-2" class="headerlink" title="Operations"></a>Operations</h5><pre><code class="C">SearchTree  MakeEmpty( SearchTree T ); 
Position  Find( ElementType X, SearchTree T ); 
Position  FindMin( SearchTree T ); 
Position  FindMax( SearchTree T ); 
SearchTree  Insert( ElementType X, SearchTree T ); 
SearchTree  Delete( ElementType X, SearchTree T ); 
ElementType  Retrieve( Position P ); 
</code></pre>
<h5 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h5><h6 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h6><p><strong>Recusive Version</strong></p>
<pre><code class="C">Position  Find( ElementType X,  SearchTree T ) 
{ 
      if ( T == NULL ) 
          return  NULL;  /* not found in an empty tree */
      if ( X &lt; T-&gt;Element )  /* if smaller than root */
          return  Find( X, T-&gt;Left );  /* search left subtree */
      else 
          if ( X &gt; T-&gt;Element )  /* if larger than root */
      return  Find( X, T-&gt;Right );  /* search right subtree */
          else   /* if X == root */
      return  T;  /* found */
} 
</code></pre>
<p><strong>Iterate Version</strong></p>
<pre><code class="C">Position  Iter_Find( ElementType X,  SearchTree T ) 
{ 
      /* iterative version of Find */
      while  ( T )   {
          if  ( X == T-&gt;Element )  
    return T ;  /* found */
          if  ( X &lt; T-&gt;Element )
             T = T-&gt;Left ; /*move down along left path */
          else
     T = T-&gt; Right ; /* move down along right path */
      }  /* end while-loop */
      return  NULL ;   /* not found */
} 
</code></pre>
<p><strong>FindMin</strong></p>
<pre><code class="C">Position  FindMin( SearchTree T ) 
{ 
      if ( T == NULL )   
          return  NULL; /* not found in an empty tree */
      else 
          if ( T-&gt;Left == NULL )   return  T;  /* found left most */
          else   return  FindMin( T-&gt;Left );   /* keep moving to left */
} 
</code></pre>
<p><strong>FindMax</strong></p>
<pre><code class="C">Position  FindMax( SearchTree T ) 
{ 
      if ( T != NULL ) 
          while ( T-&gt;Right != NULL )   
            T = T-&gt;Right;   /* keep moving to find right most */
      return T;  /* return NULL or the right most */
} 
</code></pre>
<p>$T(N)=S(N)=d$<br>where d is the depth of X</p>
<h6 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h6><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20195553.jpg" alt></p>
<pre><code class="C">SearchTree Insert( ElementType X, SearchTree T ) 
{ 
      if ( T == NULL ) { /* Create and return a one-node tree */ 
    T = malloc( sizeof( struct TreeNode ) ); 
    if ( T == NULL ) 
       FatalError( &quot;Out of space!!!&quot; ); 
    else { 
       T-&gt;Element = X; 
       T-&gt;Left = T-&gt;Right = NULL; } 
      }  /* End creating a one-node tree */
     else  /* If there is a tree */
     if ( X &lt; T-&gt;Element ) 
       T-&gt;Left = Insert( X, T-&gt;Left ); 
    else 
       if ( X &gt; T-&gt;Element ) 
          T-&gt;Right = Insert( X, T-&gt;Right ); 
       /* Else X is in the tree already; we&#39;ll do nothing */ 
    return  T;   /* Do not forget this line!! */ 
}
</code></pre>
<p>$T(N)=O(d)$<br>where d is the depth of X</p>
<h6 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h6><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20195743.jpg" alt></p>
<pre><code class="C">SearchTree  Delete( ElementType X, SearchTree T ) 
{    Position  TmpCell; 
      if ( T == NULL )   Error( &quot;Element not found&quot; ); 
      else  if ( X &lt; T-&gt;Element )  /* Go left */ 
        T-&gt;Left = Delete( X, T-&gt;Left ); 
               else  if ( X &gt; T-&gt;Element )  /* Go right */ 
               T-&gt;Right = Delete( X, T-&gt;Right ); 
             else  /* Found element to be deleted */ 
               if ( T-&gt;Left &amp;&amp; T-&gt;Right ) {  /* Two children */ 
                   /* Replace with smallest in right subtree */ 
                   TmpCell = FindMin( T-&gt;Right ); 
                   T-&gt;Element = TmpCell-&gt;Element; 
                   T-&gt;Right = Delete( T-&gt;Element, T-&gt;Right );  } /* End if */
               else {  /* One or zero child */ 
                   TmpCell = T; 
                   if ( T-&gt;Left == NULL ) /* Also handles 0 child */ 
                 T = T-&gt;Right; 
                   else  if ( T-&gt;Right == NULL )  T = T-&gt;Left; 
                   free( TmpCell );  }  /* End else 1 or 0 child */
      return  T; 
}
</code></pre>
<p>$T(N) =O(h)$<br>where h is the height of the tree</p>
<h3 id="Puzzles-1"><a href="#Puzzles-1" class="headerlink" title="Puzzles"></a>Puzzles</h3><h4 id="Judgment-and-Choice-1"><a href="#Judgment-and-Choice-1" class="headerlink" title="Judgment and Choice"></a>Judgment and Choice</h4><ol>
<li><p>There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.<br><code>F</code></p>
<blockquote>
<p>分析： 假设没有孩子的结点(叶结点)个数为n₀，只有一个孩子的结点(度为1的结点)个数为n₁，有两个孩子的结点(度为2的结点)个数为n₂。<br>则n₀+n₁+n₂=2016 ∵n₀=n₂+1(二叉树的性质：叶结点个数等于度为2的结点个数加1) ∴n₀+n₁+n₂=2016<br>⇨n₂+1+16+n₂=2016 ⇨2n₂=1999 n₂除不尽，所以答案错误。<br>公式在课本P118；<br><strong>树的节点数=所有节点的度数+1<br>二叉树，叶结点个数等于度为2的结点个数+1</strong></p>
</blockquote>
</li>
<li><p>If a general tree T is converted into a binary tree BT, then which of the following BT traversals gives the same sequence as that of the post-order traversal of T?<br><code>inorder</code> </p>
<blockquote>
<p>转换后，<br>T的preorder = BT的preorder(preorder不变)<br>T的postorder = BT的inorder</p>
</blockquote>
</li>
<li><p>As the picture showed.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20193936.jpg" alt></p>
</li>
</ol>
<blockquote>
<p>注意:左右子树不同,这棵树的左子树的左子树是空的</p>
</blockquote>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><h5 id="6-1-Isomorphic"><a href="#6-1-Isomorphic" class="headerlink" title="6-1 Isomorphic"></a>6-1 Isomorphic</h5><p>Two trees, <code>T1</code> and <code>T2</code>, are isomorphic if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in T1. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of <code>A</code>, <code>B</code>, and <code>G</code>, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20191055.jpg" alt><br><strong>Format of functions:</strong></p>
<pre><code class="C">int Isomorphic( Tree T1, Tree T2 );
</code></pre>
<p>where Tree is defined as the following:</p>
<pre><code class="C">typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};
</code></pre>
<p>The function is supposed to return <code>1</code> if <code>T1</code>and <code>T2</code> are indeed isomorphic, or <code>0</code> if not.</p>
<pre><code class="C">Sample program of judge:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef char ElementType;

typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};

Tree BuildTree(); /* details omitted */

int Isomorphic( Tree T1, Tree T2 );

int main()
{
    Tree T1, T2;
    T1 = BuildTree();
    T2 = BuildTree();
    printf(“%d\n”, Isomorphic(T1, T2));
    return 0;
}

/* Your function will be put here */
</code></pre>
<p><strong>Sample Output 1 (for the trees shown in Figure 1):</strong></p>
<pre><code>1
</code></pre><p><strong>Sample Output 2 (for the trees shown in Figure 2):</strong></p>
<pre><code>0
</code></pre><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-11-14%20191108.jpg" alt><br><strong>solution</strong></p>
<pre><code class="C">int Isomorphic( Tree T1, Tree T2 )
{
    if(T1==NULL&amp;&amp;T2==NULL)
        return 1;//First Case
    if(T1==NULL&amp;&amp;T2!=NULL)
        return 0;//Breaking Case
    if(T1!=NULL&amp;&amp;T2==NULL)
        return 0;//Breaking Case
    if (T1-&gt;Element!=T2-&gt;Element)
        return 0;//Breaking Case
    if(T1-&gt;Left==NULL&amp;&amp;T2-&gt;Left==NULL)
        return Isomorphic(T1-&gt;Right,T2-&gt;Right);
    if((T1-&gt;Left!=NULL&amp;&amp;T2-&gt;Left!=NULL)&amp;&amp;(T1-&gt;Left-&gt;Element==T2-&gt;Left-&gt;Element))
        return Isomorphic(T1-&gt;Left,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Right);
    else
        return Isomorphic(T1-&gt;Left,T2-&gt;Right)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Left);
}
</code></pre>
<h4 id="Program-1"><a href="#Program-1" class="headerlink" title="Program"></a>Program</h4><h5 id="7-1-ZigZagging-on-a-Tree"><a href="#7-1-ZigZagging-on-a-Tree" class="headerlink" title="7-1 ZigZagging on a Tree"></a>7-1 ZigZagging on a Tree</h5><p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: <code>1 11 5 8 17 12 20 15</code>.<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt><br><strong>Input Specification:</strong><br>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<p><strong>Output Specification:</strong><br>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.<br><strong>Sample Input:</strong></p>
<pre><code>8
12 11 20 17 1 15 8 5
12 20 17 11 15 8 5 1
</code></pre><p><strong>Sample Output:</strong></p>
<pre><code>1 11 5 8 17 12 20 15
</code></pre><p><strong>solution</strong></p>
<pre><code class="C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct BiTree
{
    int Element;
    struct BiTree *Left;
    struct BiTree *Right;
}BiTree,*Tree;


void ZigZaggingorder(Tree root)
{
    Tree Stack1[105];
    Tree Stack2[105];
    int top1=0;
    int top2=0;
    printf(&quot;%d&quot;,root-&gt;Element);
    if(root-&gt;Left||root-&gt;Right) printf(&quot; &quot;);
    if(root-&gt;Right!=NULL) Stack1[++top1]=root-&gt;Right;
    if(root-&gt;Left!=NULL) Stack1[++top1]=root-&gt;Left;
    int flag=-1;
    while (top1||top2)
    {
        if(flag==-1){
            while (top1)
            {
                if(Stack1[top1]-&gt;Left!=NULL) Stack2[++top2]=Stack1[top1]-&gt;Left;
                if(Stack1[top1]-&gt;Right!=NULL) Stack2[++top2]=Stack1[top1]-&gt;Right;
                if(top1==1 &amp;&amp; top2==0){
                    printf(&quot;%d&quot;,Stack1[top1]-&gt;Element);
                }
                else {
                    printf(&quot;%d &quot;,Stack1[top1]-&gt;Element);
                }
                top1--;
            }
            flag*=-1;
        }
        if(flag==1){
            while (top2)
            {
                if(Stack2[top2]-&gt;Right!=NULL) Stack1[++top1]=Stack2[top2]-&gt;Right;
                if(Stack2[top2]-&gt;Left!=NULL) Stack1[++top1]=Stack2[top2]-&gt;Left;
                if(top1==0 &amp;&amp; top2==1){
                    printf(&quot;%d&quot;,Stack2[top2]-&gt;Element);
                }
                else {
                    printf(&quot;%d &quot;,Stack2[top2]-&gt;Element);
                }
                top2--;
            }
            flag*=-1;
        }
    }
}

Tree BuildMyTree(int inorder[],int postorder[],int n)
{
    Tree T;
    if(n==0){
        return NULL;
    }
    T=(Tree)malloc(sizeof(BiTree));
    if(n==1){
        T-&gt;Element=inorder[0];
        T-&gt;Left=NULL;
        T-&gt;Right=NULL;
        return T;
    }
    int left;
    int right;
    for(int i=0;i&lt;n;i++){
        if(inorder[i]==postorder[n-1]){
            left=i;
            break;
        }
    }
    right=n-left-1;
    T-&gt;Element=postorder[n-1];
    T-&gt;Left=BuildMyTree(inorder,postorder,left);
    T-&gt;Right=BuildMyTree(inorder+left+1,postorder+left,right);
    return T;
}

int main(){
    int n;
    int inorder[105];
    int postorder[105];
    Tree T;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;inorder[i]);
    }
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;postorder[i]);
    }
    // printf(&quot;%d&quot;,inorder[0]);
    // printf(&quot;%d&quot;,postorder[0]);
    T=BuildMyTree(inorder,postorder,n);
    ZigZaggingorder(T);
    //levelorder(T);
    return 0;
}
</code></pre>
<h2 id="Union-amp-Find"><a href="#Union-amp-Find" class="headerlink" title="Union &amp; Find"></a>Union &amp; Find</h2><h3 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h3><h4 id="Symmetric"><a href="#Symmetric" class="headerlink" title="Symmetric"></a>Symmetric</h4><p>Relation is symmetric, If $(a, b) ∈ R$, then $(b, a) ∈ R$.</p>
<h4 id="Transitive"><a href="#Transitive" class="headerlink" title="Transitive"></a>Transitive</h4><p>Relation is transitive, If $(a, b) ∈ R$ &amp; $(b, c) ∈ R$, then $(a, c) ∈ R$.</p>
<h4 id="Relflexive"><a href="#Relflexive" class="headerlink" title="Relflexive"></a>Relflexive</h4><p>Relation is relflexive, If $(a, a) ∈ R$.</p>
<h4 id="Consistent"><a href="#Consistent" class="headerlink" title="Consistent"></a>Consistent</h4><p>Relation is symmetric and relflexive.</p>
<h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h4 id="Array-Data-Stucture-Implementation"><a href="#Array-Data-Stucture-Implementation" class="headerlink" title="Array Data Stucture Implementation"></a>Array Data Stucture Implementation</h4><p><code>S [element] = the element’s parent</code><br><code>S [root] = -SetSize and  set name = root&#39;s index</code></p>
<h4 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h4><pre><code class="C">void  SetUnion ( DisjSet S, SetType Rt1,SetType Rt2 )
{
    S[Rt2] = Rt1;     
}
</code></pre>
<h4 id="Find-Including-Path-Compression"><a href="#Find-Including-Path-Compression" class="headerlink" title="Find (Including Path Compression)"></a>Find (Including Path Compression)</h4><p><strong>Recursive Version</strong></p>
<pre><code class="C">SetType  Find ( ElementType  X, DisjSet  S )
{
    if ( S[ X ] &lt;= 0 )
        return  X;
    else    
        return  S[ X ] = Find( S[ X ], S );
}
</code></pre>
<p><strong>Iterate Version</strong></p>
<pre><code class="C">SetType  Find ( ElementType  X, DisjSet  S )
{   ElementType  root,  trail,  lead;
    for ( root = X; S[ root ] &gt; 0; root = S[ root ] );  /* find the root */
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[ trail ] ;   
       S[ trail ] = root ;   
    }  /* 重复再找一次，找的时候把每一层根的最终根都改掉 */
    return  root ;
}
</code></pre>
<h4 id="SetUnion-By-Size"><a href="#SetUnion-By-Size" class="headerlink" title="SetUnion By Size"></a>SetUnion By Size</h4><pre><code class="C">void SetUnion(int X1,int X2)
{
    int root1=Find(X1);
    int root2=Find(X2);
    if(root1==root2)
    {
        S[root2]=root1;
        root1-=root2;
    }
    else
    {
        if(root1&lt;root2)//root1 is bigger than root2,so we Union root2 to root1
        {
            S[root2]=root1;
            root1-=root2;//update the value of root2
        }
        else
        {
            S[root1]=root2;
            root2-=root1;
        }
    }
}
</code></pre>
<h3 id="Puzzles-2"><a href="#Puzzles-2" class="headerlink" title="Puzzles"></a>Puzzles</h3><h4 id="Judgement-amp-Choice"><a href="#Judgement-amp-Choice" class="headerlink" title="Judgement &amp; Choice"></a>Judgement &amp; Choice</h4><ol>
<li>In Union/Find algorithm, if Unions are done by size, the depth of any node must be no more than $N/2$, but not $O(logN)$.<br><code>F</code><blockquote>
<p>每做一次归并，都会使得小的集合深度加1，但是总的深度还是看大的集合。只有深度相同的归并才能使得总的深度加1，2,2归并，深度变为3；3,3归并深度变为4。因此深度最大为$log_{2}N+1$<br>所以，N次归并和M次查找，复杂度为$O(N+M\log_2N)$</p>
</blockquote>
</li>
<li>The array representation of a disjoint set containing numbers 0 to 8 is given by { 1, -4, 1, 1, -3, 4, 4, 8, -2 }. Then to union the two sets which contain 6 and 8 (with union-by-size), the index of the resulting root and the value stored at the root are:<br><code>B.4 and -5</code><blockquote>
<p>正的数代表根，负的数代表最终根以及集合的元素个数。没合并前是{0，1，2，3}，{4，5，6}，{7，8}</p>
</blockquote>
<h4 id="Program-2"><a href="#Program-2" class="headerlink" title="Program"></a>Program</h4><h5 id="7-1-File-Transfer"><a href="#7-1-File-Transfer" class="headerlink" title="7-1 File Transfer"></a>7-1 File Transfer</h5>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?<br><strong>Input Specification:</strong><br>Each input file contains one test case. For each test case, the first line contains $N (2≤N≤10^4)$, the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:<br><code>I c1 c2</code><br>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>;<br>or<br><code>C c1 c2</code><br>where <code>C</code> stands for checking if it is possible to transfer files between c1 and c2;<br>or<br><code>S</code><br>where <code>S</code> stands for stopping this case.</li>
</ol>
<p><strong>Output Specification:</strong><br>For each C case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between c1 and c2, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are k components.” where k is the number of connected components in this network.</p>
<p><strong>Sample Input 1:</strong></p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
S
</code></pre><p><strong>Sample Output 1:</strong></p>
<pre><code>no
no
yes
There are 2 components.
</code></pre><p><strong>Sample Input 2:</strong></p>
<pre><code>5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
I 1 3
C 1 5
S
</code></pre><p><strong>Sample Output 2:</strong></p>
<pre><code>no
no
yes
yes
The network is connected.
</code></pre><p><strong>Solution</strong></p>
<pre><code class="C">#include&lt;stdio.h&gt;


int Find ( int X, int S[] )
{ 
    int root, trail, lead;
    for ( root = X; S[root] &gt; 0; root = S[root] ); /* find the root */
    for ( trail = X; trail != root; trail = lead ) {
       lead = S[trail] ;   
       S[trail] = root ;   
    }/* collapsing */
    return  root ;
}

void SetUnion(int S[],int X1,int X2)
{
    int root1=Find(X1,S);
    int root2=Find(X2,S);
    if(root1==root2)
    {
        S[root2]=root1;
        root1-=root2;
    }
    else
    {
        if(root1&lt;root2)//root1 is bigger than root2,so we Union root2 to root1
        {
            S[root2]=root1;
            root1-=root2;//update the value of root2
        }
        else
        {
            S[root1]=root2;
            root2-=root1;
        }
    }
}

int main(){
    int n;
    int a,b=0;
    int cnt[10010];
    scanf(&quot;%d&quot;,&amp;n);
    int computer[10010];
    for(int i=0;i&lt;10010;i++){
        computer[i]=-1;
    }
    char c = &#39;O&#39;;
    while(c!=&#39;S&#39;){
        scanf(&quot;%c&quot;,&amp;c);
        if(c==&#39;I&#39;){
            scanf(&quot;%d&quot;,&amp;a);
            scanf(&quot;%d&quot;,&amp;b);
            SetUnion(computer,a,b);
        }
        if(c==&#39;C&#39;){
            scanf(&quot;%d&quot;,&amp;a);
            scanf(&quot;%d&quot;,&amp;b);
            if(Find(a,computer)==Find(b,computer)){
                printf(&quot;yes\n&quot;);
            }
            if(Find(a,computer)!=Find(b,computer)){
                printf(&quot;no\n&quot;);
            }
        }
    }
    int flag=0;
    for(int i=1;i&lt;=n;i++){
        if(computer[i]&lt;0){
            flag++;
        }
    }
    if(flag==1){
         printf(&quot;The network is connected.&quot;);
    }
    else{
        printf(&quot;There are %d components.\n&quot;,flag);
    }
    return 0;
}
</code></pre>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><p>$G( V, E )$  where  $G$ ::= graph,<br>$V = V( G )$ ::= finite nonempty set of vertices,<br>and $E = E( G )$ ::= finite set of edges.<br><strong>Undirected graph:</strong>  $( vi , vj ) = ( vj , vi )$ ::= the same edge.<br><strong>Directed graph (digraph):</strong>  $&lt; v_i , v_j &gt; ::= v_i -&gt; v_j  \neq &lt; vj , vi &gt;$<br>In this class,Restrictions :<br>(1)  Self loop is illegal.<br>(2)  Multigraph is not considered<br>(Multigraph: A Graph that there could be more than one edge between two nodes)<br><strong>Complete graph:</strong>  a graph that has the maximum number of edges<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20165015.gif" alt><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20165307.gif" alt></p>
<h3 id="Simple-Implementation-of-Graph"><a href="#Simple-Implementation-of-Graph" class="headerlink" title="Simple Implementation of Graph"></a>Simple Implementation of Graph</h3><h4 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a>Adjacency Matrix</h4><p><code>adj_mat[n][n]</code> is defined for $G(V, E)$ with $n$ vertices, $n &gt; 1$ :<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/AdjMat.png" alt><br>Note: If G is undirected, then <code>adj_mat[ ][ ]</code> is <strong>symmetric</strong>.<br>Thus we can save space by storing only half of the matrix.<br>In a word, the advantage of adjacency matrix is simple to implement, <strong>but the disadvantage is waste of space.</strong> In praxtice,for most incomplete graphs, more than half of the space is often wasted.</p>
<h4 id="Adjacency-Lists"><a href="#Adjacency-Lists" class="headerlink" title="Adjacency Lists"></a>Adjacency Lists</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20170109.gif" alt><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20170222.gif" alt></p>
<h5 id="Simple-Implementation-in-C"><a href="#Simple-Implementation-in-C" class="headerlink" title="Simple Implementation in C"></a>Simple Implementation in C</h5><pre><code class="C">typedef int Vertex;         /* 用顶点下标表示顶点,为整型 */
typedef int WeightType;        /* 边的权值设为整型 */
typedef char DataType;        /* 顶点存储的数据类型设为字符型 */

/* 边的定义 */
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1, V2;      /* 有向边&lt;V1, V2&gt; */
    WeightType Weight;  /* 权重 */
};
typedef PtrToENode Edge;

/* 邻接点的定义 */
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;        /* 邻接点下标 */
    WeightType Weight;  /* 边权重 */
    PtrToAdjVNode Next;    /* 指向下一个邻接点的指针 */
};

/* 顶点表头结点的定义 */
typedef struct Vnode{
    PtrToAdjVNode FirstEdge;/* 边表头指针 */
    DataType Data;            /* 存顶点的数据 */
    /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */
} AdjList[MaxVertexNum];    /* AdjList是邻接表类型 */

/* 图结点的定义 */
typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;     /* 顶点数 */
    int Ne;     /* 边数   */
    AdjList G;  /* 邻接表 */
};
typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */

LGraph CreateGraph( int VertexNum )
{ /* 初始化一个有VertexNum个顶点但没有边的图 */
    Vertex V;
    LGraph Graph;

    Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */
    Graph-&gt;Nv = VertexNum;
    Graph-&gt;Ne = 0;
    /* 初始化邻接表头指针 */
    /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */
       for (V=0; V&lt;Graph-&gt;Nv; V++){
            Graph-&gt;G[V].FirstEdge = NULL;
       }
    return Graph; 
}

void InsertEdge( LGraph Graph, Edge E )
{
    PtrToAdjVNode NewNode;

    /* 插入边 &lt;V1, V2&gt; */
    /* 为V2建立新的邻接点 */
    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V2;
    NewNode-&gt;Weight = E-&gt;Weight;
    /* 将V2插入V1的表头 */
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;

    /* 若是无向图，还要插入边 &lt;V2, V1&gt; */
    /* 为V1建立新的邻接点 */
    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV = E-&gt;V1;
    NewNode-&gt;Weight = E-&gt;Weight;
    /* 将V1插入V2的表头 */
    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;
}

LGraph BuildGraph()
{
    LGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;

    scanf(&quot;%d&quot;, &amp;Nv);   /* 读入顶点个数 */
    Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ 

    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   /* 读入边数 */
    if ( Graph-&gt;Ne != 0 ) { /* 如果有边 */ 
        E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ 
        /* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */
        for (i=0; i&lt;Graph-&gt;Ne; i++) {
            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            /* 注意：如果权重不是整型，Weight的读入格式要改 */
            InsertEdge( Graph, E );
        }
    } 

    /* 如果顶点有数据的话，读入数据 */
    for (V=0; V&lt;Graph-&gt;Nv; V++) {
        scanf(&quot; %c&quot;, &amp;(Graph-&gt;G[V].Data));
    }
    return Graph;
}
</code></pre>
<h3 id="Toplogical-Sort"><a href="#Toplogical-Sort" class="headerlink" title="Toplogical Sort"></a>Toplogical Sort</h3><h4 id="Definition-5"><a href="#Definition-5" class="headerlink" title="Definition"></a>Definition</h4><p><strong>AOV Network</strong> ::= digraph $G$ in which $V( G )$ represents activities ( e.g.  the courses ) and $E( G )$ represents precedence relations ( e.g.  means that C1 is a prerequisite course of C3 ).<br>$i$ is a predecessor of $j$ ::= there is a path from $i$ to $j$<br>$i$ is an immediate predecessor of  $j ::= &lt; i$,  $j &gt; \in E( G )$,then $j$ is called a <strong>successor</strong> ( immediate successor ) of $i$<br><strong>Partial order</strong> ::= a precedence relation which is both <strong>transitive</strong> $( i \to k, k \to j  \Rightarrow  i \to j )$ and <strong>irreflexive</strong> ( $i \to i$ is impossible ).<br>(which means there must be no circles)<br><strong>A topological order</strong> is a linear ordering of the vertices of a graph such that, for any two vertices, $i, j,$ if $i$ is a predecessor of $j$ in the network then $i$ precedes $j$ in the linear ordering.</p>
<h4 id="Normal-Implementation"><a href="#Normal-Implementation" class="headerlink" title="Normal Implementation"></a>Normal Implementation</h4><pre><code class="C">void Topsort( Graph G )
{   int  Counter;
    Vertex  V, W;
    for ( Counter = 0; Counter &lt; NumVertex; Counter ++ ) {
        V = FindNewVertexOfDegreeZero( );
        if ( V == NotAVertex ) {
            Error ( “Graph has a cycle” );   break;  }
        TopNum[ V ] = Counter; /* or output V */
        for ( each W adjacent to V ){
                Indegree[ W ] – – ;
        }
    }
}
</code></pre>
<p>Analyse the time complexity:$T = O( |V|^2 )$</p>
<h4 id="Implementation-with-Queue"><a href="#Implementation-with-Queue" class="headerlink" title="Implementation with Queue"></a>Implementation with Queue</h4><pre><code class="C">void Topsort( Graph G )
{   
    Queue  Q;
    int  Counter = 0;
    Vertex  V, W;
    Q = CreateQueue( NumVertex );
    MakeEmpty( Q );
    for ( each vertex V )
    if ( Indegree[ V ] == 0 ){
        Enqueue( V, Q );
    }
    while ( !IsEmpty( Q ) ) {
        V = Dequeue( Q );
        TopNum[ V ] = ++ Counter; /* assign next */
        for ( each W adjacent to V ){
            if ( – – Indegree[ W ] == 0 ) {
                Enqueue( W, Q );
            }
        }
    }  /* end-while */
    if ( Counter != NumVertex ){
        Error( “Graph has a cycle” );
    }
    DisposeQueue( Q ); /* free memory */
}
</code></pre>
<p>Analyse the time complexity:$T = O( |V|+|E| )$</p>
<h3 id="Shortest-Path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h3><p>Given a digraph $G = ( V, E )$, and a cost function $c( e )$ for $e \in E( G )$.   <strong>The length of a path $P$</strong> from source to destination is $\sum_{e_i \in P}c(e_i)$ (also called weighted path length).</p>
<h4 id="Simple-representation"><a href="#Simple-representation" class="headerlink" title="Simple representation"></a>Simple representation</h4><pre><code class="C">Table[ i ].Dist ::= distance from s to vi  /* initialized to be $\infin$ except for s */
Table[ i ].Known ::= 1 if vi is checked; or 0 if not
Table[ i ].Path ::= for tracking the path   /* initialized to be 0 *,上一个点/
</code></pre>
<h4 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h4><h5 id="Unweighted-Graph-with-a-Queue"><a href="#Unweighted-Graph-with-a-Queue" class="headerlink" title="Unweighted Graph with a Queue"></a>Unweighted Graph with a Queue</h5><pre><code class="C">void Unweighted( Table T )
{   /* T is initialized with the source vertex S given */
    Queue  Q;
    Vertex  V, W;
    Q = CreateQueue (NumVertex );  
    MakeEmpty( Q );
    Enqueue( S, Q ); /* Enqueue the source vertex */
    while ( !IsEmpty( Q ) ) {
        V = Dequeue( Q );
        T[ V ].Known = true; /* not really necessary */
        for ( each W adjacent to V ){
            if ( T[ W ].Dist == Infinity ) {
                T[ W ].Dist = T[ V ].Dist + 1;
                T[ W ].Path = V;
                Enqueue( W, Q );
            } /* end-if Dist == Infinity */
        }
    } /* end-while */
    DisposeQueue( Q ); /* free memory */
}
</code></pre>
<p>$T = O( |V|+|E| )$</p>
<h5 id="Dijkstra’s-Algorithm-for-Weighted-Graph"><a href="#Dijkstra’s-Algorithm-for-Weighted-Graph" class="headerlink" title="Dijkstra’s Algorithm for Weighted Graph"></a>Dijkstra’s Algorithm for Weighted Graph</h5><pre><code class="C">void Dijkstra( Table T )
{   /* T is initialized by Figure 9.30 on p.303 */
    Vertex  V, W;
    for ( ; ; ) {
        V = smallest unknown distance vertex;
        if ( V == NotAVertex ){
            break; 
        }
        T[ V ].Known = true;
        for ( each W adjacent to V ){
            if ( !T[ W ].Known ){
                if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) {
                    Decrease( T[ W ].Dist  to T[ V ].Dist + Cvw );
                    T[ W ].Path = V;
                } /* end-if update W */
                //Cvw: the weight of the edge form v to w
            }
        }
    } /* end-for( ; ; ) */
}
</code></pre>
<p>NOTE:This algorithm does not work for edge with negative cost.<br>$T = O( |V|^2 + |E| )$<br><strong>If this algorithm work with a priority queue</strong>,the time complexity could be<br>$T = O( |V| log|V| + |E| log|V| ) = O( |E| log|V| )$</p>
<h4 id="Acyclic-Graphs"><a href="#Acyclic-Graphs" class="headerlink" title="Acyclic Graphs"></a>Acyclic Graphs</h4><p>If the graph is acyclic, <strong>vertices may be selected in topological order</strong> since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</p>
<h3 id="Network-Flow-Problem"><a href="#Network-Flow-Problem" class="headerlink" title="Network Flow Problem"></a>Network Flow Problem</h3><p>$G=(V,E)$是一个有向图，其中每条边$(u,v)∈E$均有一个非负容量$c(u,v)&gt;=0$。如果$(u,v) \notin E$，则假定$c(u,v)=0$。流网络中有两个特别的顶点：源点$s$和汇点$t$。下图展示了一个流网络的实例。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202023-01-02%20195823.jpg" alt></p>
<h3 id="Minimum-Spanning-Tree"><a href="#Minimum-Spanning-Tree" class="headerlink" title="Minimum Spanning Tree"></a>Minimum Spanning Tree</h3><p>A spanning tree of a graph $G$ is a tree which consists of $V( G )$ and a subset of $E( G )$</p>
<p><strong>Note:</strong></p>
<ol>
<li>The minimum spanning tree is a tree since it is acyclic – the number of edges is $|V| – 1$.</li>
<li>It is minimum for the total cost of edges is minimized.</li>
<li>It is spanning because it covers every vertex.</li>
<li>A minimum spanning tree exists iff $G$ is connected.</li>
<li>Adding a non-tree edge to a spanning tree, we obtain a cycle</li>
</ol>
<h4 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h4><p>对<strong>顶点</strong>操作，在最小生成树的顶点集$U$和待处理顶点集$V-U$中，不断地寻找最短边(代价最小边)，找到后将对应顶点加入集合$U$，直到所有顶点均处理完毕($V-U$里没有剩余顶点),<strong>DFS</strong></p>
<p><strong>Prim算法如何保证不成环？因为每次选择的点都是在集合$V$以外的</strong></p>
<h5 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h5><pre><code class="C">/* 邻接矩阵存储 - Prim最小生成树算法 */

Vertex FindMinDist( MGraph Graph, WeightType dist[] )
{ /* 返回未被收录顶点中dist最小者 */
    Vertex MinV, V;
    WeightType MinDist = INFINITY;

    for (V=0; V&lt;Graph-&gt;Nv; V++) {
        if ( dist[V]!=0 &amp;&amp; dist[V]&lt;MinDist) {
            /* 若V未被收录，且dist[V]更小 */
            MinDist = dist[V]; /* 更新最小距离 */
            MinV = V; /* 更新对应顶点 */
        }
    }
    if (MinDist &lt; INFINITY) /* 若找到最小dist */
        return MinV; /* 返回对应的顶点下标 */
    else return ERROR;  /* 若这样的顶点不存在，返回-1作为标记 */
}

int Prim( MGraph Graph, LGraph MST )
{ /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */
    WeightType dist[MaxVertexNum], TotalWeight;
    Vertex parent[MaxVertexNum], V, W;
    int VCount;
    Edge E;

    /* 初始化。默认初始点下标是0 */
    for (V=0; V&lt;Graph-&gt;Nv; V++) {
        /* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY */
           dist[V] = Graph-&gt;G[0][V];
           parent[V] = 0; /* 暂且定义所有顶点的父结点都是初始点0 */ 
    }
    TotalWeight = 0; /* 初始化权重和     */
    VCount = 0;      /* 初始化收录的顶点数 */
    /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */
    MST = CreateGraph(Graph-&gt;Nv);
    E = (Edge)malloc( sizeof(struct ENode) ); /* 建立空的边结点 */

    /* 将初始点0收录进MST */
    dist[0] = 0;
    VCount ++;
    parent[0] = -1; /* 当前树根是0 */

    while (1) {
        V = FindMinDist( Graph, dist );
        /* V = 未被收录顶点中dist最小者 */
        if ( V==ERROR ) /* 若这样的V不存在 */
            break;   /* 算法结束 */

        /* 将V及相应的边&lt;parent[V], V&gt;收录进MST */
        E-&gt;V1 = parent[V];
        E-&gt;V2 = V;
        E-&gt;Weight = dist[V];
        InsertEdge( MST, E );
        TotalWeight += dist[V];
        dist[V] = 0;
        VCount++;

        for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */
            if ( dist[W]!=0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) {
            /* 若W是V的邻接点并且未被收录 */
                if ( Graph-&gt;G[V][W] &lt; dist[W] ) {
                /* 若收录V使得dist[W]变小 */
                    dist[W] = Graph-&gt;G[V][W]; /* 更新dist[W] */
                    parent[W] = V; /* 更新树 */
                }
            }
    } /* while结束*/
    if ( VCount &lt; Graph-&gt;Nv ) /* MST中收的顶点不到|V|个 */
       TotalWeight = ERROR;
    return TotalWeight;   /* 算法执行完毕，返回最小权重和或错误标记 */
</code></pre>
<h4 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a>Kruskal’s Algorithm</h4><p>对<strong>边</strong>操作，每次选取一条最短边，如果不会和当前最小生成树构成环（回路），将此最短边加入最小生成树中。当选取了$n-1$（顶点数-1）条边，或找出了所有符合条件的不成环边最小生成树生成完毕,<strong>BFS</strong></p>
<pre><code class="C">void Kruskal ( Graph G )
{   T = { } ;
    while  ( T contains less than |V| - 1 edges &amp;&amp; E is not empty ) {
        choose a least cost edge (v, w) from E ;
        delete (v, w) from E ;
        if  ( (v, w) does not create a cycle in T )     
            add (v, w) to T ;
        else     
            discard (v, w) ;
    }
    if  ( T contains fewer than |V| - 1 edges )
        Error ( “No spanning tree” ) ;
}
</code></pre>
<p>Analysis:$T=O(|E|log|E|)$</p>
<h5 id="Implementation-7"><a href="#Implementation-7" class="headerlink" title="Implementation"></a>Implementation</h5><pre><code class="C">/* 邻接表存储 - Kruskal最小生成树算法 */

/*-------------------- 顶点并查集定义 --------------------*/
typedef Vertex ElementType; /* 默认元素可以用非负整数表示 */
typedef Vertex SetName;     /* 默认用根结点的下标作为集合名称 */
typedef ElementType SetType[MaxVertexNum]; /* 假设集合元素下标从0开始 */

void InitializeVSet( SetType S, int N )
{ /* 初始化并查集 */
    ElementType X;

    for ( X=0; X&lt;N; X++ ) S[X] = -1;
}

void Union( SetType S, SetName Root1, SetName Root2 )
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if ( S[Root2] &lt; S[Root1] ) { /* 如果集合2比较大 */
        S[Root2] += S[Root1];     /* 集合1并入集合2  */
        S[Root1] = Root2;
    }
    else {                         /* 如果集合1比较大 */
        S[Root1] += S[Root2];     /* 集合2并入集合1  */
        S[Root2] = Root1;
    }
}

SetName Find( SetType S, ElementType X )
{ /* 默认集合元素全部初始化为-1 */
    if ( S[X] &lt; 0 ) /* 找到集合的根 */
        return X;
    else
        return S[X] = Find( S, S[X] ); /* 路径压缩 */
}

bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )
{ /* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */
    Vertex Root1, Root2;

    Root1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */
    Root2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */

    if( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */
        return false;
    else { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */
        Union( VSet, Root1, Root2 );
        return true;
    }
}
/*-------------------- 并查集定义结束 --------------------*/

/*-------------------- 边的最小堆定义 --------------------*/
void PercDown( Edge ESet, int p, int N )
{ /* 改编代码4.24的PercDown( MaxHeap H, int p )    */
  /* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */
    int Parent, Child;
    struct ENode X;

    X = ESet[p]; /* 取出根结点存放的值 */
    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) {
        Child = Parent * 2 + 1;
        if( (Child!=N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )
            Child++;  /* Child指向左右子结点的较小者 */
        if( X.Weight &lt;= ESet[Child].Weight ) break; /* 找到了合适位置 */
        else  /* 下滤X */
            ESet[Parent] = ESet[Child];
    }
    ESet[Parent] = X;
}

void InitializeESet( LGraph Graph, Edge ESet )
{ /* 将图的边存入数组ESet，并且初始化为最小堆 */
    Vertex V;
    PtrToAdjVNode W;
    int ECount;

    /* 将图的边存入数组ESet */
    ECount = 0;
    for ( V=0; V&lt;Graph-&gt;Nv; V++ )
        for ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next )
            if ( V &lt; W-&gt;AdjV ) { /* 避免重复录入无向图的边，只收V1&lt;V2的边 */
                ESet[ECount].V1 = V;
                ESet[ECount].V2 = W-&gt;AdjV;
                ESet[ECount++].Weight = W-&gt;Weight;
            }
    /* 初始化为最小堆 */
    for ( ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount-- )
        PercDown( ESet, ECount, Graph-&gt;Ne );
}

int GetEdge( Edge ESet, int CurrentSize )
{ /* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */

    /* 将最小边与当前堆的最后一个位置的边交换 */
    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);
    /* 将剩下的边继续调整成最小堆 */
    PercDown( ESet, 0, CurrentSize-1 );

    return CurrentSize-1; /* 返回最小边所在位置 */
}
/*-------------------- 最小堆定义结束 --------------------*/


int Kruskal( LGraph Graph, LGraph MST )
{ /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */
    WeightType TotalWeight;
    int ECount, NextEdge;
    SetType VSet; /* 顶点数组 */
    Edge ESet;    /* 边数组 */

    InitializeVSet( VSet, Graph-&gt;Nv ); /* 初始化顶点并查集 */
    ESet = (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );
    InitializeESet( Graph, ESet ); /* 初始化边的最小堆 */
    /* 创建包含所有顶点但没有边的图。注意用邻接表版本 */
    MST = CreateGraph(Graph-&gt;Nv);
    TotalWeight = 0; /* 初始化权重和     */
    ECount = 0;      /* 初始化收录的边数 */

    NextEdge = Graph-&gt;Ne; /* 原始边集的规模 */
    while ( ECount &lt; Graph-&gt;Nv-1 ) {  /* 当收集的边不足以构成树时 */
        NextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */
        if (NextEdge &lt; 0) /* 边集已空 */
            break;
        /* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */
        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )==true ) {
            /* 将该边插入MST */
            InsertEdge( MST, ESet+NextEdge );
            TotalWeight += ESet[NextEdge].Weight; /* 累计权重 */
            ECount++; /* 生成树中边数加1 */
        }
    }
    if ( ECount &lt; Graph-&gt;Nv-1 )
        TotalWeight = -1; /* 设置错误标记，表示生成树不存在 */

    return TotalWeight;
}
</code></pre>
<h3 id="Depth-First-Search-DFS"><a href="#Depth-First-Search-DFS" class="headerlink" title="Depth-First Search(DFS)"></a>Depth-First Search(DFS)</h3><h4 id="Implementatiom"><a href="#Implementatiom" class="headerlink" title="Implementatiom"></a>Implementatiom</h4><pre><code class="C">void DFS ( Vertex V )  /* this is only a template */
{   visited[ V ] = true;  /* mark this vertex to avoid cycles */
    for ( each W adjacent to V )
        if ( !visited[ W ] )
    DFS( W );
} /* T = O( |E| + |V| ) as long as adjacency lists are used */
</code></pre>
<h4 id="Application-1-List-Components"><a href="#Application-1-List-Components" class="headerlink" title="Application 1: List Components"></a>Application 1: List Components</h4><pre><code class="C">void ListComponents ( Graph G ) 
{   for ( each V in G ) 
        if ( !visited[ V ] ) {
    DFS( V );
               printf(“\n“);
        }
}
</code></pre>
<h4 id="Application-2-Biconnectivity"><a href="#Application-2-Biconnectivity" class="headerlink" title="Application 2: Biconnectivity"></a>Application 2: Biconnectivity</h4><p><strong>【Definition】</strong><br><strong>articulation point:</strong> $v$ is an articulation point if $G’ = DeleteVertex( G, v )$ has at least 2 connected components.<br><strong>biconnected graph:</strong> $G$ is a biconnected graph if $G$ is connected and has no articulation points.<br><strong>biconnected component:</strong> A biconnected component is a maximal biconnected subgraph.<br>Now, we want to find the <strong>biconnected components</strong> of a connected <strong>undirected</strong> $G$.</p>
<p><strong>Solution:</strong><br>Find the articulation points in $G$:</p>
<ul>
<li>The root is an articulation point if it has at least 2 children</li>
<li>Any other vertex $u$ is an articulation point if $u$ has at least 1 child, and it is impossible to move down at least 1 step and then jump up to u’s ancestor,which means that :<strong>$u$ is not the root, and has at least 1 child such that  $Low( child ) \geq Num( u )$</strong>.</li>
</ul>
<p>$Num(u)$:DFS遍历时顶点的序号<br>$Low(u)$:原图中和该顶点有边的顶点的最低序号<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202023-01-04%20121207.png" alt><br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202023-01-04%20121232.gif" alt><br>In this graph,vertices {1，3，5，7} are articulation point.</p>
<h5 id="Implementation-in-C"><a href="#Implementation-in-C" class="headerlink" title="Implementation in C"></a>Implementation in C</h5><pre><code class="C">#define min(x,y) ((x)&gt;(y)?(y):(x))
void DFS(int u, Graph G, void(*visit)(Vertex V)){
    num[u]=low[u]=count++;
    stack[++top] = u;
    instack[u]=true;

    for(PtrToVNode v =G-&gt;Array[u];v;v=v-&gt;Next){
        //和G相邻的点
        if (!instack[v-&gt;Vert] &amp;&amp; !visited[v-&gt;Vert]) {
            DFS(v-&gt;Vert, G, visit);
            //v-&gt;Vert:v的节点编号
            low[u] = min(low[u], low[v-&gt;Vert]);
        }
        else if (instack[v-&gt;Vert]) {
            low[u] = min(low[u], num[v-&gt;Vert]);
        }
    }

    Vertex poped_v = -1;
    if (num[u] == low[u]) {
        while (poped_v != u) {
            poped_v=stack[top--];
            visit(poped_v);
            instack[poped_v] = false;
            visited[poped_v] = true;
        }
        printf(&quot;\n&quot;);
    }

}
</code></pre>
<h4 id="Application-3-Euler-Circuits"><a href="#Application-3-Euler-Circuits" class="headerlink" title="Application 3: Euler Circuits"></a>Application 3: Euler Circuits</h4><p><strong>【Definition】</strong></p>
<ul>
<li><strong>Euler tour</strong>: Draw each line exactly once without lifting your pen from the paper.</li>
<li><strong>Euler curcuit</strong>: Draw each line exactly once without lifting your pen from the paper, AND finish at the starting point.</li>
</ul>
<p><strong>【Proposition】</strong> </p>
<ul>
<li><strong>An Euler circuit</strong> is possible only if the graph is <strong>connected</strong> and each vertex has an <strong>even</strong> degree.</li>
<li><strong>An Euler tour</strong> is possible if there are <strong>exactly two vertices having odd degree</strong>.  One must start at one of the odd-degree vertices.</li>
</ul>
<h3 id="Puzzles-3"><a href="#Puzzles-3" class="headerlink" title="Puzzles"></a>Puzzles</h3><h4 id="Judgement-amp-Choice-1"><a href="#Judgement-amp-Choice-1" class="headerlink" title="Judgement &amp; Choice"></a>Judgement &amp; Choice</h4><h4 id="Program-3"><a href="#Program-3" class="headerlink" title="Program"></a>Program</h4><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><h3 id="Inseration-Sort"><a href="#Inseration-Sort" class="headerlink" title="Inseration Sort"></a>Inseration Sort</h3><h4 id="Implementation-8"><a href="#Implementation-8" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="C">void InsertionSort ( ElementType A[ ], int N ) 
{ 
      int  j, P; 
      ElementType  Tmp; 

      for ( P = 1; P &lt; N; P++ ) { 
    Tmp = A[ P ];  /* the next coming card */
    for ( j = P; j &gt; 0 &amp;&amp; A[ j - 1 ] &gt; Tmp; j-- ) 
          A[ j ] = A[ j - 1 ]; 
          /* shift sorted cards to provide a position 
                       for the new coming card */
    A[ j ] = Tmp;  /* place the new card at the proper position */
      }  /* end for-P-loop */
}
</code></pre>
<h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p><strong>The worst case</strong>:Input <code>A[ ]</code> is in reverse order.   $T( N ) = O( N^2 )$</p>
<p><strong>The best case</strong>:Input <code>A[ ]</code> is in sorted order.  $T( N ) = O( N )$</p>
<h3 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h3><h4 id="Implementation-9"><a href="#Implementation-9" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="C">void Shellsort( ElementType A[ ], int N ) 
{ 
      int  i, j, Increment; 
      ElementType  Tmp; 
      for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  
    /*h sequence */
    for ( i = Increment; i &lt; N; i++ ) { /* insertion sort */
          Tmp = A[ i ]; 
          for ( j = i; j &gt;= Increment; j - = Increment ) 
        if( Tmp &lt; A[ j - Increment ] ) 
              A[ j ] = A[ j - Increment ]; 
        else 
              break; 
        A[ j ] = Tmp; 
    } /* end for-I and for-Increment loops */
}
</code></pre>
<h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h3><h4 id="Implementation-10"><a href="#Implementation-10" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="C">void PercDown(int A[], int N, int p) {
    int parent, child;
    int temp = A[p];
    for (parent = p; 2 * parent + 1 &lt; N; parent = child) {
        child = 2 * parent + 1;
        if (child + 1 &lt; N &amp;&amp; A[child + 1] &gt; A[child])
            child++;
        if (temp &lt; A[child])
            A[parent] = A[child];
        else
            break;
    }
    A[parent] = temp;
}

void Heapsort( ElementType A[ ], int N ) 
{  int i; 
    for ( i = N / 2; i &gt;= 0; i - - ) /* BuildHeap */ 
        PercDown( A, i, N ); 
    for ( i = N - 1; i &gt; 0; i - - ) { 
        Swap( &amp;A[ 0 ], &amp;A[ i ] ); /* DeleteMax */ 
        PercDown( A, 0, i ); 
    } 
}
</code></pre>
<h3 id="QuickSort-Median-3-version"><a href="#QuickSort-Median-3-version" class="headerlink" title="QuickSort(Median-3 version)"></a>QuickSort(Median-3 version)</h3><h4 id="Implementation-11"><a href="#Implementation-11" class="headerlink" title="Implementation"></a>Implementation</h4><pre><code class="C">#define Cutoff 5
/*小数据下插入排序更快，不足Cutoff用插入排序*/

void  Quicksort( ElementType A[ ], int N ) 
{ 
    Qsort( A, 0, N - 1 ); 
    /* A:     the array     */
    /* 0:     Left index     */
    /* N – 1: Right index    */
}//面向对象思想，封装过程

/* Return median of Left, Center, and Right */ 
/* Order these and hide the pivot */ 
ElementType Median3( ElementType A[ ], int Left, int Right ) 
{ 
    int  Center = ( Left + Right ) / 2; 
    if ( A[ Left ] &gt; A[ Center ] ) 
        Swap( &amp;A[ Left ], &amp;A[ Center ] ); 
    if ( A[ Left ] &gt; A[ Right ] ) 
        Swap( &amp;A[ Left ], &amp;A[ Right ] ); 
    if ( A[ Center ] &gt; A[ Right ] ) 
        Swap( &amp;A[ Center ], &amp;A[ Right ] ); 
    /* Invariant: A[ Left ] &lt;= A[ Center ] &lt;= A[ Right ] */ 
    Swap( &amp;A[ Center ], &amp;A[ Right - 1 ] ); /* Hide pivot */ 
    /* only need to sort A[ Left + 1 ] … A[ Right – 2 ] */
    return  A[ Right - 1 ];  /* Return pivot */ 
}

void  Qsort( ElementType A[ ], int Left, int Right ) 
{   
    int  i,  j; 
    ElementType  Pivot; 
    if ( Left + Cutoff &lt;= Right ) {  /* if the sequence is not too short */
            Pivot = Median3( A, Left, Right );  /* select pivot */
            i = Left;     j = Right – 1;  /* why not set Left+1 and Right-2? */
        for( ; ; ) { 
            while ( A[ + +i ] &lt; Pivot ) { }  /* scan from left */
            while ( A[ – –j ] &gt; Pivot ) { }  /* scan from right */
            if ( i &lt; j ) 
                Swap( &amp;A[ i ], &amp;A[ j ] );  /* adjust partition */
            else break;  /* partition done */
        }
            Swap( &amp;A[ i ], &amp;A[ Right - 1 ] ); /* restore pivot */ 
            Qsort( A, Left, i - 1 );      /* recursively sort left part */
            Qsort( A, i + 1, Right );   /* recursively sort right part */
        }  /* end if - the sequence is long */
    else /* do an insertion sort on the short subarray */ 
            InsertionSort( A + Left, Right - Left + 1 );
    }
</code></pre>
<h3 id="Complexity-and-Stability"><a href="#Complexity-and-Stability" class="headerlink" title="Complexity and Stability"></a>Complexity and Stability</h3><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/v2-0872ff222124611b3403a888be76c2b9_1440w.jpg" alt></p>
<h3 id="Puzzles-4"><a href="#Puzzles-4" class="headerlink" title="Puzzles"></a>Puzzles</h3><h4 id="Judgment-and-Choice-2"><a href="#Judgment-and-Choice-2" class="headerlink" title="Judgment and Choice"></a>Judgment and Choice</h4><ol>
<li><p>During the sorting, processing every element which is not yet at its final position is called a “run”. Which of the following cannot be the result after the second run of quicksort?<br> A.5, 2, 16, 12, 28, 60, 32, 72<br> B.2, 16, 5, 28, 12, 60, 32, 72<br> C.2, 12, 16, 5, 28, 32, 72, 60<br> D.5, 2, 12, 28, 16, 32, 72, 60<br><code>D</code></p>
<blockquote>
<p>三个pivot , 快速排序每一轮的过程, <strong>观察有几个元素在正确的位置</strong>, 每轮当分割点pivot的元素一定会在正确的位置。最理想的是每次都选到中间值, 这样两轮后有三个分割点。<br>A选项，28和72在正确位置, B选项，2和72在正确位置。他们是因为选到了最值72,所以是两个pivot。C选择2和28,32在正确位置。D选项，没有选到最值, 又没有三个pivot, 就是错的。</p>
</blockquote>
</li>
<li><p>Given input { 321, 156, 57, 46, 28, 7, 331, 33, 34, 63 }. Which one of the following is the result after the 2nd run of the Least Signification Digit (LSD) radix sort?<br> A.→7→321→28→34→33→331→156→46→57→63<br> B.→7→321→28→331→34→33→46→156→57→63<br> C.→156→28→321→331→33→34→46→57→63→7<br> D.→7→321→28→331→33→34→46→156→57→63<br><code>D</code></p>
<blockquote>
<p>第一次按照个位排：321-&gt;331-&gt;33-&gt;63-&gt;34-&gt;156-&gt;46-&gt;57-&gt;7-&gt;28<br>第二次按照十位排：7-&gt;321-&gt;28-&gt;331-&gt;33-&gt;34-&gt;46-&gt;156-&gt;57-&gt;63</p>
</blockquote>
</li>
<li><p>Among the following sorting methods, which ones will be slowed down if we store the elements in a linked structure instead of a sequential structure?<br>Insertion sort; 2. Selection Sort; 3. Bubble sort; 4. Shell sort; 5. Heap sort<br>A.1 and 2 only<br>B.2 and 3 only<br>C.3 and 4 only<br>D.4 and 5 only<br><code>D</code></p>
<blockquote>
<p>如果在链表中存储数据，变慢的操作是：访问第 $n$ 个元素，变快的是插入。shell需要访问第 $k$ 个元素，heap需要访问 $i/2$ 的元素。</p>
</blockquote>
</li>
</ol>
<h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><h3 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h3><h4 id="Definition-6"><a href="#Definition-6" class="headerlink" title="Definition"></a>Definition</h4><p>e.g.<br>In a symbol table for a compiler<br>name = identifier (e.g. int)<br>attribute = a list of lines that use the identifier, and some other fields</p>
<p>这里先说一下哈希表的定义：哈希表是一种根据关键码去寻找值的数据映射结构，该结构通过把关键码映射的位置去寻找存放值的地方，说起来可能感觉有点复杂，我想我举个例子你就会明白了，最典型的的例子就是字典，大家估计小学的时候也用过不少新华字典吧，如果我想要获取“按”字详细信息，我肯定会去根据拼音<code>an</code>去查找 拼音索引(当然也可以是偏旁索引)，我们首先去查<code>an</code>在字典的位置，查了一下得到“安”，结果如下。这过程就是键码映射，在公式里面，就是通过<code>key</code>去查找<code>f(key)</code>。其中，按就是关键字<code>(key)</code>，<code>f()</code>就是字典索引，也就是哈希函数，查到的页码4就是哈希值。<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-26%20232104.gif" alt><br>细分T和key<br>T：key的值域<br>n：实际的key的数量</p>
<h4 id="Collision-amp-Overflow"><a href="#Collision-amp-Overflow" class="headerlink" title="Collision &amp; Overflow"></a>Collision &amp; Overflow</h4><p><strong>A collision occurs</strong> when we hash two nonidentical identifiers into the same bucket, i.e.  $f ( i1 ) = f ( i2 )$ when $i1 \neq i2$ .<br>但是问题又来了，我们要查的是“按”，而不是“安，但是他们的拼音都是一样的。也就是通过关键字按和关键字安可以映射到一样的字典页码4的位置，这就是哈希冲突(也叫哈希碰撞)，在公式上表达就是key1≠key2，但f(key1)=f(key2)。冲突会给查找带来麻烦，你想想，你本来查找的是“按”，但是却找到“安”字，你又得向后翻一两页，在计算机里面也是一样道理的。</p>
<p><strong>An overflow occurs</strong> when we hash a new identifier into a full bucket.</p>
<h3 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h3><ol>
<li>$f ( x )$ must be easy to compute and <strong>minimizes the number of collisions</strong>.</li>
<li><strong>$f ( x )$ should be unbiased.</strong>  That is, for any x and any i, we have that Probability$( f ( x ) = i ) = 1 / b$.  Such kind of a hash function is called a uniform hash function.</li>
</ol>
<h3 id="Implementation-12"><a href="#Implementation-12" class="headerlink" title="Implementation"></a>Implementation</h3><h4 id="Struct-Definition"><a href="#Struct-Definition" class="headerlink" title="Struct Definition"></a>Struct Definition</h4><pre><code class="C">struct  ListNode; 
typedef  struct  ListNode  *Position; 
struct  HashTbl; 
typedef  struct  HashTbl  *HashTable; 
struct  ListNode { 
    ElementType  Element; 
    Position  Next; 
}; 
typedef  Position  List; 
/* List *TheList will be an array of lists, allocated later */ 
/* The lists use headers (for simplicity), */ 
/* though this wastes space */ 
struct  HashTbl { 
    int  TableSize; 
    List  *TheLists; 
}; 
</code></pre>
<h4 id="Create-Table"><a href="#Create-Table" class="headerlink" title="Create Table"></a>Create Table</h4><pre><code class="C">HashTable  InitializeTable( int TableSize ) 
{   HashTable  H; 
    int  i; 
    if ( TableSize &lt; MinTableSize ) { 
        Error( &quot;Table size too small&quot; );  return NULL;  
    } 
    H = malloc( sizeof( struct HashTbl ) );  /* Allocate table */
    if ( H == NULL )    FatalError( &quot;Out of space!!!&quot; ); 
    H-&gt;TableSize = NextPrime( TableSize );  /* Better be prime */
    H-&gt;TheLists = malloc( sizeof( List ) * H-&gt;TableSize );  /*Array of lists*/
    if ( H-&gt;TheLists == NULL )   FatalError( &quot;Out of space!!!&quot; ); 
    for( i = 0; i &lt; H-&gt;TableSize; i++ ) {   /* Allocate list headers */
    H-&gt;TheLists[ i ] = malloc( sizeof( struct ListNode ) ); /* Slow! */
    if ( H-&gt;TheLists[ i ] == NULL )  FatalError( &quot;Out of space!!!&quot; ); 
    else    H-&gt;TheLists[ i ]-&gt;Next = NULL;
    } 
    return  H; 
} 
</code></pre>
<h4 id="Find-1"><a href="#Find-1" class="headerlink" title="Find"></a>Find</h4><pre><code class="C">Position  Find ( ElementType Key, HashTable H ) 
{ 
    Position P; 
    List L; 

    L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; 

    P = L-&gt;Next; 
    while( P != NULL &amp;&amp; P-&gt;Element != Key )  /* Probably need strcmp */ 
    P = P-&gt;Next; 
    return P; 
} 
</code></pre>
<h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><pre><code class="C">void  Insert ( ElementType Key, HashTable H ) 
{ 
    Position   Pos, NewCell; 
    List  L; 
    Pos = Find( Key, H ); 
    if ( Pos == NULL ) {   /* Key is not found, then insert */
        NewCell = malloc( sizeof( struct ListNode ) ); 
        if ( NewCell == NULL )     FatalError( &quot;Out of space!!!&quot; ); 
        else { 
            L = H-&gt;TheLists[ Hash( Key, H-&gt;TableSize ) ]; 
            NewCell-&gt;Next = L-&gt;Next; 
            NewCell-&gt;Element = Key; /* Probably need strcpy! */ 
            L-&gt;Next = NewCell; 
        } 
    } 
} 
</code></pre>
<h4 id="Separate-Chaining"><a href="#Separate-Chaining" class="headerlink" title="Separate Chaining"></a>Separate Chaining</h4><p>使用链接散列表。这个是使用链表解决冲突。表的长度由题目给定。</p>
<h4 id="Open-Adressing"><a href="#Open-Adressing" class="headerlink" title="Open Adressing"></a>Open Adressing</h4><pre><code class="C">Algorithm: insert key into an array of hash table
{
    index = hash(key);
    initialize i = 0// the counter of probing;
    while ( collision at index ) {
    index = ( hash(key) + f(i) ) % TableSize;
    if ( table is full )    break;
    else    i ++;
    }
    if ( table is full )
    ERROR (“No space left”);
    else
    insert key at index;
}
</code></pre>
<p><strong>$f(x)$:Collision resolving function.$f(0) = 0.$</strong></p>
<h4 id="Liner-Probing"><a href="#Liner-Probing" class="headerlink" title="Liner Probing"></a>Liner Probing</h4><p>$f(i) = i$<br><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20082643.gif" alt></p>
<h4 id="Quadratic-Probing"><a href="#Quadratic-Probing" class="headerlink" title="Quadratic Probing"></a>Quadratic Probing</h4><p>$f ( i ) = i^2 $<br>【Theorem】<br>If quadratic probing is used, and the table size is prime, then a new element can always be inserted if the table is at least half empty.<br>【Proof】<br>Just prove that the first $[TableSize/2]$ alternative locations are all distinct.<br>That is, for any<br>$0 &lt; i \neq j &lt; [TableSize/2]$, we have<br>$( h(x) + i^2 )\% TableSize  \neq  ( h(x) + j^2 ) \%   TableSize $<br>Suppose:    $ h(x) + i^2 = h(x) + j^2 ( mod \ TableSize )$<br>then:<br> $i^2 = j^2 ( mod \ TableSize )$<br> $( i + j ) ( i - j ) = 0  (mod \ TableSize )$</p>
<p>BUT as TableSize is prime,either $( i + j )$ or $( i - j )$ is divisible by TableSize!<br>Contradiction !<br>Q.E.D.</p>
<h5 id="Implementation-in-Quadratic-Probing"><a href="#Implementation-in-Quadratic-Probing" class="headerlink" title="Implementation in Quadratic Probing"></a>Implementation in Quadratic Probing</h5><h6 id="Find-2"><a href="#Find-2" class="headerlink" title="Find"></a>Find</h6><pre><code class="C">Position  Find ( ElementType Key, HashTable H ) 
{   Position  CurrentPos; 
    int  CollisionNum; 
    CollisionNum = 0; 
    CurrentPos = Hash( Key, H-&gt;TableSize ); 
    while( H-&gt;TheCells[ CurrentPos ].Info != Empty &amp;&amp; 
    H-&gt;TheCells[ CurrentPos ].Element != Key ) 
    { 
        CurrentPos += 2 * ++CollisionNum - 1; 
        //(i+1)^2-i^2=2*(i+1)-1
        if ( CurrentPos &gt;= H-&gt;TableSize )  CurrentPos - = H-&gt;TableSize; 
    } 
    return CurrentPos; 
} 
</code></pre>
<h6 id="Insertion-1"><a href="#Insertion-1" class="headerlink" title="Insertion"></a>Insertion</h6><pre><code class="C">void  Insert ( ElementType Key, HashTable H ) 
{ 
    Position  Pos; 
    Pos = Find( Key, H ); 
    if ( H-&gt;TheCells[ Pos ].Info != Legitimate ) { /* OK to insert here */ 
    H-&gt;TheCells[ Pos ].Info = Legitimate; 
    H-&gt;TheCells[ Pos ].Element = Key; /* Probably need strcpy */ 
    } 
} 
</code></pre>
<h4 id="Double-Hashing"><a href="#Double-Hashing" class="headerlink" title="Double Hashing"></a>Double Hashing</h4><p><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/FDS_Review/屏幕截图%202022-12-27%20090515.gif" alt></p>
<h4 id="Rehashing"><a href="#Rehashing" class="headerlink" title="Rehashing"></a>Rehashing</h4><p>动态增长哈希表</p>
<ol>
<li>Build another table that is about twice as big;(find the closest prime to the two times big size)</li>
<li>Scan down the entire original hash table for non-deleted elements;</li>
<li>Use a new function to hash those elements into the new table.</li>
</ol>
<p>When to Rehash?</p>
<ul>
<li>As soon as the table is half full</li>
<li>When an insertion fails</li>
<li>When the table reaches a certain load factor</li>
</ul>
<p>Usually there should have been $N/2$ insertions before rehash, so $O(N)$ rehash only adds a constant cost to each insertion.<br>However, in an interactive system, the unfortunate user whose insertion caused a rehash could see a slowdown.</p>
<p>通过第一个$hash_1(x)$计算，比如<br>$hash_1(x)=key\%TableSize$,若此时出现冲突，使用如下的公式计算<br>$(hash_1(key) + i * hash_2(key)) \% TableSize $。<br>还有冲突就增加$i$。</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/custom/donate/AliPay.jpg"></li>
                <li class="wechat-code"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/custom/donate/WeChatPay.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
        
          
            <div class="post-nepre full next">
          
            <a href="/2022/08/19/孙吧顶真/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://gcore.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/dingzhen/dingzhen.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/img/post/dingzhen/dingzhen.jpg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                孙吧顶针</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "cufCqTylUQUH7Ez5kCgC3fbR-MdYXbMMI",
        appKey: "lychiSFCksLLUOndXBDAsg3A",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>



    <script src="//cdn.jsdelivr.net/npm/@waline/client"></script>
    <div id="waline"></div>
    <style>
    #waline textarea {
        box-sizing: border-box;
        background: url("https://gitee.com/cungudafa/source/raw/master/img/gif/Sitich/Sitich2.gif") 100% 100% no-repeat;
    }
    </style>
    <script>
        Waline({
              el: '#waline',
              serverURL: 'https://waline-j7soumapm-orwell-yu.vercel.app/',
              pageSize: '10',
              lang: 'zh-CN',
              requiredFields: ['nick','mail'], //设置必填项
              placeholder: 'Ciallo～(∠・ω &lt; )⌒☆',
              visitor: 'true',
              emoji: [
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili',
                  'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo',
              ],
              avatar: 'mp',
              dark: 'auto',
            });
    </script>


      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="" class="profile gravatar"><img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg" itemprop="image" alt="mio" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="" itemprop="url" rel="author">mio</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>正在复习ing</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Orwell-Yu<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2022</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://gcore.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://gcore.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

	<!--浏览器搞笑标题-->
<script src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/js/hititle.js"></script>
	<!-- 🌸飘落 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js"></script>
	<!-- 雪花飘落 -->
	<!-- <script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js"></script> -->
	<!-- // 文字 -->
<script src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/js/click.js"></script>
	<!-- // 烟花 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/fireworks.js"></script>
	<!-- // 星星跟随坠落 -->
<script src="https://cdn.jsdelivr.net/gh/cungudafa/cdn@2.1.2/js/cursor.js"></script>
	<!-- // 爱心 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script>
	<!-- // 连线 -->
	<!-- <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>
	<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script> -->
	<!-- 样式二（飘动的彩带） -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js" type="text/javascript"></script>
	 <!-- 背景切换
<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script> -->
<!-- 实时通信 -->

  <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f6b2a0b1.js","daovoice")
    daovoice('init', {
      app_id: "900fd0f3"
    });
    daovoice('update');
  </script>
  

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://gcore.jsdelivr.net/gh/Orwell-Yu/cdn@latest/face/mio avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">秋山澪の小站</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/Orwell-Yu" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://twitter.com/yu_zhewen" class="fa fa-twitter" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="hhttps://user.qzone.qq.com/1955026836" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/资源/">
                  <i class="fa fa-cloud-download" aria-hidden="true"></i>
                  资源
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/图集/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            赞赏
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="7598981325"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>